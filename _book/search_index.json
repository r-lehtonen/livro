[["index.html", "Análises de Dados com R Prefácio", " Análises de Dados com R Ricardo Lehtonen R. de Souza 2023-07-31 Prefácio Na pesquisa científica, a análise de dados é uma parte fundamental e o R é uma linguagem que possibilita a fazer as mais diversas análises, não é apenas uma ferramenta estatística. O R é um software livre e uma grande comunidade trabalha aperfeiçoando a ferramenta e todo dia temos novidades, tornando o aprendizado muito dinâmico. Há alguns anos, achei importante estimular o uso do R pelos discentes do Programa de Pós-Graduação em Genética da Universidade Federal do Paraná (UFPR), assim reformulei a disciplina de Bioinformática, introduzindo o R. Na primeira oferta da disciplina refomulada, trouxe minha amiga, a Dra Kelly Nunes, para ministrar a disciplina. De lá para cá já foram muitos discentes que passaram pela disciplina e fico contente ao ver eles utilizando o R em suas análises. Mais recentemente, havia uma demanda para aprender R por parte do curso de Biomedicina da UFPR, então propus criar uma disciplina optativa para a graduação, a qual foi ofertada inicialmente para os cursos de Biomedicina e Ciências Biológicas. Esse livro surgiu da necessidade de organizar o material didático que uso nessas disciplinas, de forma a facilitar a atualização das informações e disponibilização para os discentes. ISBN: 978-65-00-76198-6 "],["introdução.html", "Capítulo 1 Introdução 1.1 O que é R 1.2 Instalação 1.3 RStudio 1.4 Objetos do R 1.5 Nomes dos objetos do R 1.6 Vetores 1.7 Operações com Vetores 1.8 Fatores 1.9 Matrizes 1.10 Listas 1.11 Data frame 1.12 Sequências", " Capítulo 1 Introdução 1.1 O que é R O R é uma linguagem de alto nível e um ambiente para análise de dados e geração de gráficos. Alguns pensam que o R é apenas um pacote estatístico, no entanto, o R é muito mais do que isso, embora a parte estatística seja um dos pontos fortes do R. O R tem código aberto, ou seja, pode ser modificado, aprimorado a qualquer momento por qualquer usuário. Ele foi criado em 1991, na Nova Zelândia (University of Auckland) por Ross Ihaka e Robert Gentleman. O R está estruturado em duas partes principais, a base do R e os pacotes que podemos ir instalando. Existem milhares de pacotes do R para as mais diversas funções, que encontramos no repositórios: CRAN package repository. Bioconductor. Para saber como citar o R, basta usar o seguinte comando: citation() ## To cite R in publications use: ## ## R Core Team (2023). _R: A Language and Environment for Statistical ## Computing_. R Foundation for Statistical Computing, Vienna, Austria. ## &lt;https://www.R-project.org/&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2023}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite it ## when using it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for ## citing R packages. Ajuda sobre o R O R tem um sistema de ajuda bastante elaborado que lhe permitirá obter muita informação extra sobre a linguagem, bem como muitos outros aspectos. Usando a interface gráfica (RStudio), podemos obter ajuda através do menu Help Se pretende simplesmente obter ajuda sobre uma função em particular do R, a forma mais simples é usar a função help(): help(sqrt) Além disso, disso existem muito material disponível na internet, abaixo estão alguns exemplos: Stackoverflow https://stackoverflow.com/questions/tagged/r Rdocumentation https://www.rdocumentation.org/ Rseek https://rseek.org/ R-bloggers https://www.r-bloggers.com/ 1.2 Instalação O primeiro passo é instalar o R. Podemos baixar a última versão em https://cran.r-project.org/ Nesse mesmo site temos a lista de pacotes disponíveis. Quando atualizamos o R, temos que instalar novamente os pacotes que tínhamos na versão anterior. Para facilitar, temos um pacote chamado installr, que permite atualizar o R, copiar e atualizar os pacotes para a nova versão. 1.3 RStudio Apesar de podermos utilizar o R diretamente no console, o uso da interface gráfica RStudio facilta muito o uso do R. Podemos baixar o RStudio de https://posit.co/downloads/ No seguinte link tem dicas de como usar o RStudio: https://posit.co/wp-content/uploads/2022/10/rstudio-ide-1.pdf 1.4 Objetos do R O R é uma linguagem baseada em objetos, de forma que as coisas que usamos ficam na memória do computador sob a forma de um objeto. Esses objetos recebem um nome e podem armazenar diferentes tipos de informações como números, texto, vetores, matrizes, expressões, etc. Para armazenar algo num objeto usamos o operador de atribuição: &lt;- Exemplo: x1 &lt;- 0.6 Para ver o conteúdo do objeto: x1 ## [1] 0.6 O [1] que aparece antes do número guardado no objeto mostra o número da linha do conteúdo do objeto. A operação de atribuição é destrutiva no sentido que ao atribuir um novo valor a um objeto existente, vamos perder o conteúdo que ele estava armazenado anteriormente. Também podemos atribuir expressões numéricas a objetos. O resultado de tal operação é o de que o resultado do cálculo da expressão e não a expressão propriamente dita: x2 &lt;- 15 x3 &lt;- x2^3 x3 ## [1] 3375 Os objetos que criamos ficam na memória do computador e se quisermos podemos apagar um objeto. Podemos ver quais os objetos atualmente na memória do computador usando as funções ls() ou objects(). Se não necessitamos de algum dos objetos podemos apagá-lo com a função rm() No RStudio, podemos ver os objetos na aba environment e, se quisermos apagar todos os objetos, podemos clicar no ícone da vassoura, nesta mesma aba. 1.5 Nomes dos objetos do R Para darmos nome para os objetos podemos usar letras maiúsculas ou minúsculas, os dígitos 0 a 9 (exceto no início do nome), o ponto final e não podemos usar espaços. Lembre-se de que o R é sensível às letras maiúsculas / minúsculas, por exemplo, o nome dados é diferente de Dados. 1.6 Vetores Um dos principais objetos do R para é o vetor. Um vetor é uma estrutura de dados que permite armazenar um conjunto de valores do mesmo tipo (por exemplo números) sob um mesmo nome. Esses elementos podem depois ser acessados individualmente usando um esquema de indexação. Este tipo de estrutura de dados é bastante útil quando pretendemos armazenar várias coisas relacionadas. Todos os vetores em R tem um modo e um tamanho. O modo determina o tipo de valores guardado no vetor. Em R podemos ter vetores com modo character, logical, numeric e complex. Ou seja, podemos ter vetores para armazenar os seguintes tipos de dados: conjuntos de caracteres, valores lógicos (F ou T ou FALSE ou TRUE), números inteiros ou reais, e números complexos Para criar vetores usamos a função c() e separamos os elementos por vírgulas. Por exemplo, para armazenar um conjunto de notas: notas &lt;- c(4, 7, 10, 9.5, 7.5) notas ## [1] 4.0 7.0 10.0 9.5 7.5 Comprimento e modo do vetor: length(notas) ## [1] 5 mode(notas) ## [1] &quot;numeric&quot; Ao criar um vetor temos que cuidar para que todos os elementos sejam do mesmo tipo (modo). Se criarmos um vetor com tipos diferentes, o R vai forçá-los a ser do mesmo tipo, como no exemplo a seguir: notas2 &lt;- c(6, 10, 7.5, 9, 8, &quot;nc&quot;) notas2 ## [1] &quot;6&quot; &quot;10&quot; &quot;7.5&quot; &quot;9&quot; &quot;8&quot; &quot;nc&quot; O vetor criado será do tipo caracter. No exemplo anterior coloquei nc para quem não compareceu. Para resolver isso temos outra alternativa, que veremos a seguir. No R temos um elemento especial que é o NA. Este valor representa um valor desconhecido. Por exemplo, se temos a idade de pacientes guardados num vetor, mas não temos essa informação de um indivíduo, podemos criar esse vetor: idade&lt;- c(23, 45, NA, 34) idade ## [1] 23 45 NA 34 Os elementos de um vetor podem ser acessados através de um índice: idade[2] ## [1] 45 O R permite criar vetores vazios usando a função vector(): x4 &lt;- vector() O tamanho de um vetor existente pode ser alterado atribuindo mais elementos a índices até agora inexistentes: x4[3] &lt;- 60 x4 ## [1] NA NA 60 1.7 Operações com Vetores A linguagem R permite vetorizar a maioria das suas funções. Por exemplo, a função sqrt() que serve para calcular raíz quadrada: x5 &lt;- c(9, 16, 25, 36, 49) x5 &lt;- sqrt(x5) x5 ## [1] 3 4 5 6 7 O R pode ser usado para fazer operações aritméticas envolvendo vetores: x6 &lt;- c(5, 10, 15) x7 &lt;- c(20, 20, 20) x6 + x7 ## [1] 25 30 35 No entanto, se os vetores tiverem tamanhos diferentes, o R vai reciclar os valores do vetor mais curto até este atingir o tamanho do maior. Por exemplo: x8 &lt;- c(5, 10, 15, 20) x9 &lt;- c(5, 10) x8 + x9 ## [1] 10 20 20 30 1.8 Fatores Quando temos variáveis categóricas, podemos usar outro tipo de objeto do R, o fator. Cada fator tem um conjunto de níveis. Vamos ver um exemplo. Suponhamos que pretendemos guardar o genótipo de 10 indivíduos em um vetor: gt &lt;- c(&quot;CC&quot;, &quot;CT&quot;, &quot;CC&quot;, &quot;CC&quot;, &quot;CT&quot;, &quot;TT&quot;, &quot;CT&quot;, &quot;CT&quot;, &quot;TT&quot;, &quot;CT&quot;) gt ## [1] &quot;CC&quot; &quot;CT&quot; &quot;CC&quot; &quot;CC&quot; &quot;CT&quot; &quot;TT&quot; &quot;CT&quot; &quot;CT&quot; &quot;TT&quot; &quot;CT&quot; Para transformar esse vetor de caracteres em um fator, usamos a função factor: gt &lt;- factor(gt) gt ## [1] CC CT CC CC CT TT CT CT TT CT ## Levels: CC CT TT Suponha agora que temos 4 indivíduos cujo genótipo pretendemos armazenar. Imagine que por coincidência não aparece o genótipo TT. Se pretendemos que o fator resultante mantenha os 3 níveis possíveis, teremos que fazer: gt2 &lt;- factor(c(&quot;CC&quot;, &quot;CT&quot;, &quot;CT&quot;, &quot;CT&quot;), levels = c(&quot;CC&quot;, &quot;CT&quot;,&quot;TT&quot;)) gt2 ## [1] CC CT CT CT ## Levels: CC CT TT Podemos usar a função table contar o número de ocorrências de cada valor (nível): table(gt) ## gt ## CC CT TT ## 3 5 2 table(gt2) ## gt2 ## CC CT TT ## 1 3 0 Para fatores do mesmo tamanho usamos a função table() para fazer tabulações cruzadas de dois fatores. Usando o fator gt, com os genótipos dos indivíduos, e um novo fator com os grupos (caso x controle), podemos fazer uma tabulação cruzada entre genótipos e e grupo: grupo &lt;- factor(c(&quot;caso&quot;, &quot;caso&quot;, &quot;controle&quot;, &quot;controle&quot;, &quot;caso&quot;, &quot;caso&quot;, &quot;caso&quot;, &quot;controle&quot;, &quot;caso&quot;, &quot;controle&quot;)) table(gt, grupo) ## grupo ## gt caso controle ## CC 1 2 ## CT 3 2 ## TT 2 0 Também é possível obter frequências marginais e relativas: tabela &lt;- table(gt, grupo) margin.table(tabela, 1) ## gt ## CC CT TT ## 3 5 2 Frequências relativas com a função prop.table(): prop.table(tabela, 1) ## grupo ## gt caso controle ## CC 0.3333333 0.6666667 ## CT 0.6000000 0.4000000 ## TT 1.0000000 0.0000000 prop.table(tabela, 2) ## grupo ## gt caso controle ## CC 0.1666667 0.5000000 ## CT 0.5000000 0.5000000 ## TT 0.3333333 0.0000000 prop.table(tabela) ## grupo ## gt caso controle ## CC 0.1 0.2 ## CT 0.3 0.2 ## TT 0.2 0.0 1.9 Matrizes Para armazenar os dados em estruturas com mais do que uma dimensão usamos as matrizes arranjam a informação em duas dimensões. Para criar uma matriz usamos uma função específica para isso. Se quisermos criar uma matriz de 3 linhas e 4 colunas: dados &lt;- matrix(c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120), 3, 4) dados ## [,1] [,2] [,3] [,4] ## [1,] 10 40 70 100 ## [2,] 20 50 80 110 ## [3,] 30 60 90 120 Os números são colocados na matriz por coluna, mas se quisermos preencher a matriz por linhas da seguinte forma: dados2 &lt;- matrix(c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120), 3, 4, byrow = T) dados2 ## [,1] [,2] [,3] [,4] ## [1,] 10 20 30 40 ## [2,] 50 60 70 80 ## [3,] 90 100 110 120 Nas matrizes podemos dar nomes para linhas e colunas. Vejamos como fazer isso no exemplo anterior: rownames(dados) &lt;- c(&quot;caso1&quot;, &quot;caso2&quot;, &quot;caso3&quot;) colnames(dados) &lt;- c(&quot;var1&quot;, &quot;var2&quot;, &quot;var3&quot;, &quot;var4&quot;) dados ## var1 var2 var3 var4 ## caso1 10 40 70 100 ## caso2 20 50 80 110 ## caso3 30 60 90 120 Podemos acessar elementos individuais das matrizes usando um esquema de indexação: dados[2, 2] ## [1] 50 Ou então, usando os nomes: dados[&quot;caso1&quot;, &quot;var2&quot;] ## [1] 40 As funções cbind() e rbind() podem ser usadas para juntar dois ou mais vetores ou matrizes, por colunas ou por linhas, respectivamente, como podemos ver a seguir: ex1 &lt;- c(15, 25, 65, 75) ex2&lt;-c(10, 20, 30, 40) m1&lt;-cbind(ex1, ex2) m1 ## ex1 ex2 ## [1,] 15 10 ## [2,] 25 20 ## [3,] 65 30 ## [4,] 75 40 m2&lt;-rbind(ex1, ex2) m2 ## [,1] [,2] [,3] [,4] ## ex1 15 25 65 75 ## ex2 10 20 30 40 As regras aritméticas também se aplicam as matrizes. m1 * 3 ## ex1 ex2 ## [1,] 45 30 ## [2,] 75 60 ## [3,] 195 90 ## [4,] 225 120 1.10 Listas Outro objeto que temos é a lista. Na lista podemos colocar coisas variadas, que não precisam ser do mesmo tipo, modo ou tamanho. Os componentes de uma lista em R são sempre numerados e podem também ter um nome associados a eles. Por exemplo, podemos criar uma lista com vários objetos criados anteriormente: lt &lt;- list(idade, gt, dados) lt[[1]] ## [1] 23 45 NA 34 1.11 Data frame Um data frame é um objeto do R usado para guardar tabelas de dados de um problema qualquer. É muito semelhante a uma matriz, mas as suas colunas tem nomes e podem conter dados de tipo diferente, diferente da matriz. Um data frame pode ser visto como uma tabela de uma base de dados, em que cada linha corresponde a um registro (linha) da tabela. Cada coluna corresponde às propriedades (campos) a serem armazenadas para cada registro da tabela. dados2 &lt;- data.frame(idade = c(50, 45, 30, 20), genotipo = c(&quot;CC&quot;, &quot;CT&quot;, &quot;CT&quot;, &quot;TT&quot;), sexo = c(&quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;)) dados2 ## idade genotipo sexo ## 1 50 CC M ## 2 45 CT F ## 3 30 CT M ## 4 20 TT F 1.12 Sequências Para gerar dados sequenciais, em vez digitar os valores, podemos gerar sequências de várias de formas. Por exemplo, para criar um vetor com os números de 1 a 100, em vez de os escrevermos todos, podemos usar: x &lt;- 1:100 Exemplos: seq(from = 1, to = 5, length = 4) ## [1] 1.000000 2.333333 3.666667 5.000000 seq(from = 1, to = 5, length = 2) ## [1] 1 5 seq(length = 10, from = -2, by = 0.2) ## [1] -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2 letters[1:10] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; Uma outra função bastante útil para gerar sequências é a função rep(): rep(5, 10) ## [1] 5 5 5 5 5 5 5 5 5 5 rep(&quot;sim&quot;, 3) ## [1] &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; rep(1:3, 2) ## [1] 1 2 3 1 2 3 Para ler um pouco mais sobre o assunto: (Torgo 2011) References "],["carregar-e-manipular-dados.html", "Capítulo 2 Carregar e manipular dados 2.1 Ler arquivos txt e csv 2.2 Ler arquivos xlsx 2.3 Gravar arquivos txt e xlsx 2.4 Manipulação de dados (R base) 2.5 Transformação de dados 2.6 Técnicas de normalização 2.7 Juntar dados (R base)", " Capítulo 2 Carregar e manipular dados Dados Uma etapa muito importante é planejar as planilhas de dados. Se os dados estiverem bem organizados, isso vai poupar muito tempo. Como os dados devem estar organizados: os casos nas linhas e as variáveis nas colunas. Os dados podem estar em planilhas do excel ou em arquivos de texto. Vamos ver como carregar esses dados. 2.1 Ler arquivos txt e csv Para ler um arquivo txt usamos a função read.table. No exemplo abaixo, o arquivo iris.txt está dentro pasta dados: dados&lt;-read.table(&quot;dados/iris.txt&quot;, head=T, sep = &quot;,&quot;) head(dados) ## sepal_l sepal_w petal_l petal_w class ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.9 3.0 1.4 0.2 Iris-setosa ## 3 4.7 3.2 1.3 0.2 Iris-setosa ## 4 4.6 3.1 1.5 0.2 Iris-setosa ## 5 5.0 3.6 1.4 0.2 Iris-setosa ## 6 5.4 3.9 1.7 0.4 Iris-setosa tail(dados) ## sepal_l sepal_w petal_l petal_w class ## 145 6.7 3.3 5.7 2.5 Iris-virginica ## 146 6.7 3.0 5.2 2.3 Iris-virginica ## 147 6.3 2.5 5.0 1.9 Iris-virginica ## 148 6.5 3.0 5.2 2.0 Iris-virginica ## 149 6.2 3.4 5.4 2.3 Iris-virginica ## 150 5.9 3.0 5.1 1.8 Iris-virginica Onde head=T indica que os dados tem uma linha de cabeçalho e sep define o separador das variáveis, nesse caso é a vírgula. Use help(“read.table”) para ver outros parâmetros. Podemos ver as primeiras linhas do objeto head e as últimas linhas com tail. 2.2 Ler arquivos xlsx Instale e ative o pacote openxlsx. Temos duas maneiras de instalar um pacote. No RStudio, podemos clicar em Install na aba Packages e então digitar o nome do pacote a ser instalado. Ou podemos usar a função install.packages(), especificando o nome do pacote dentro do parêntesis. Sempre que formos utilizar um pacote, precisamos ativá-lo. Também temos duas maneiras de fazer isso. A primeira, usando o RStudio, na aba Packages procuramos o pacote e clicamos na caixa de seleção. A segunda maneira, a qual recomendo usar, é com a função library(). Dessa forma, a ativação já estará no script e não corremos o risco de esquecer de ativar o pacote. O pacote openxlsx permite ler e gravar arquivo xlsx, como no exemplo abaixo: library(openxlsx) dados2&lt;-read.xlsx(&quot;dados/pinguim.xlsx&quot;, sheet = 1, colNames = T) head(dados2) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex year ## 1 male 2007 ## 2 female 2007 ## 3 female 2007 ## 4 &lt;NA&gt; 2007 ## 5 female 2007 ## 6 male 2007 Onde sheet especifica qual planilha do arquivo xlsx deve ser lida e colNames = T indica que na primeira linha estão os títulos das colunas. Podemos definir outros parâmetros também, como por exemplo, especificar em qual linha começar a ler os dados com startRow =, ou definir quais colunas pegar com cols =. Também é possível usar a opção do RStudio para importar dados para isso, na aba environment, clique em import Dataset tem opções de importar dados do texto, do excel, do SPSS e outros formatos. 2.3 Gravar arquivos txt e xlsx Gravar arquivos Podemos gravar um arquivo txt ou xlsx write.table(dados, file=&quot;dados/flor.txt&quot;, quote=F, row.names = F,append=F) write.xlsx(dados, &quot;dados/flor.xlsx&quot;, sheetName=&quot;Plan1&quot;, colNames=T, rowNames=F,append=F) 2.4 Manipulação de dados (R base) Com a função summary podemos ver um resumo sobre uma variável: summary(dados$sepal_l) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 4.300 5.100 5.800 5.843 6.400 7.900 Para especificar a variável, usamos o nome do objeto seguido de $ e o nome da coluna Podemos ver um resumo de todas as variáveis: summary(dados) ## sepal_l sepal_w petal_l petal_w ## Min. :4.300 Min. :2.000 Min. :1.000 Min. :0.100 ## 1st Qu.:5.100 1st Qu.:2.800 1st Qu.:1.600 1st Qu.:0.300 ## Median :5.800 Median :3.000 Median :4.350 Median :1.300 ## Mean :5.843 Mean :3.054 Mean :3.759 Mean :1.199 ## 3rd Qu.:6.400 3rd Qu.:3.300 3rd Qu.:5.100 3rd Qu.:1.800 ## Max. :7.900 Max. :4.400 Max. :6.900 Max. :2.500 ## class ## Length:150 ## Class :character ## Mode :character ## ## ## Podemos ver as características das variáveis usando a função str: str(dados) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ sepal_l: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ sepal_w: num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ petal_l: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ petal_w: num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ class : chr &quot;Iris-setosa&quot; &quot;Iris-setosa&quot; &quot;Iris-setosa&quot; &quot;Iris-setosa&quot; ... Indexação Podemos usar indexação para acessar dados específicos. dados[2,3] # [linha, coluna] ## [1] 1.4 dados[,3] # todos os dados da coluna 3 ## [1] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 1.5 1.6 1.4 1.1 1.2 1.5 1.3 1.4 ## [19] 1.7 1.5 1.7 1.5 1.0 1.7 1.9 1.6 1.6 1.5 1.4 1.6 1.6 1.5 1.5 1.4 1.5 1.2 ## [37] 1.3 1.5 1.3 1.5 1.3 1.3 1.3 1.6 1.9 1.4 1.6 1.4 1.5 1.4 4.7 4.5 4.9 4.0 ## [55] 4.6 4.5 4.7 3.3 4.6 3.9 3.5 4.2 4.0 4.7 3.6 4.4 4.5 4.1 4.5 3.9 4.8 4.0 ## [73] 4.9 4.7 4.3 4.4 4.8 5.0 4.5 3.5 3.8 3.7 3.9 5.1 4.5 4.5 4.7 4.4 4.1 4.0 ## [91] 4.4 4.6 4.0 3.3 4.2 4.2 4.2 4.3 3.0 4.1 6.0 5.1 5.9 5.6 5.8 6.6 4.5 6.3 ## [109] 5.8 6.1 5.1 5.3 5.5 5.0 5.1 5.3 5.5 6.7 6.9 5.0 5.7 4.9 6.7 4.9 5.7 6.0 ## [127] 4.8 4.9 5.6 5.8 6.1 6.4 5.6 5.1 5.6 6.1 5.6 5.5 4.8 5.4 5.6 5.1 5.1 5.9 ## [145] 5.7 5.2 5.0 5.2 5.4 5.1 dados[2,] # todos os dados da linha 2 ## sepal_l sepal_w petal_l petal_w class ## 2 4.9 3 1.4 0.2 Iris-setosa dados$sepal_w # todos os dados da coluna sepal_w ## [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 3.5 ## [19] 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 3.1 3.2 ## [37] 3.5 3.1 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 3.2 3.1 2.3 ## [55] 2.8 2.8 3.3 2.4 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 2.2 2.5 3.2 2.8 ## [73] 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 3.4 3.1 2.3 3.0 2.5 ## [91] 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 3.0 2.9 3.0 3.0 2.5 2.9 ## [109] 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 3.0 3.8 2.6 2.2 3.2 2.8 2.8 2.7 3.3 3.2 ## [127] 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2 ## [145] 3.3 3.0 2.5 3.0 3.4 3.0 colnames(dados) # nomes das colunas ## [1] &quot;sepal_l&quot; &quot;sepal_w&quot; &quot;petal_l&quot; &quot;petal_w&quot; &quot;class&quot; Selecionando dados. Como exemplo, vamos selecionar apenas as linhas que correspondem à espécie Iris virginica. Os dados referentes à espécie estão na variável class. virginica&lt;- dados[dados$class==&quot;Iris-virginica&quot;,] A indexação é linha, coluna. A vírgula no final sem nada depois significa que é para pegar todos as colunas. Se quisermos pegar só a coluna 3 usamos assim: petal_virginica&lt;-dados[dados$class==&quot;Iris-virginica&quot;, 3] Podemos selecionar algumas colunas. No exemplo abaixo selecionamos as colunas 3 a 5: dados3&lt;-dados2[, c(3:5)] Como a indexação é linha, coluna, dentro dos [] tem uma vírgula e nada antes da vírgula, isso significa pegar todas as linhas, depois da vírgula está especificado para pegar as colunas de 3 a 5. Criando uma coluna Criando uma coluna chamada índice com NA: dados$indice&lt;-NA dados$indice ## [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [101] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA ## [126] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA Adicionando dados: dados$indice&lt;-(dados$sepal_l*dados$sepal_w) head(dados) ## sepal_l sepal_w petal_l petal_w class indice ## 1 5.1 3.5 1.4 0.2 Iris-setosa 17.85 ## 2 4.9 3.0 1.4 0.2 Iris-setosa 14.70 ## 3 4.7 3.2 1.3 0.2 Iris-setosa 15.04 ## 4 4.6 3.1 1.5 0.2 Iris-setosa 14.26 ## 5 5.0 3.6 1.4 0.2 Iris-setosa 18.00 ## 6 5.4 3.9 1.7 0.4 Iris-setosa 21.06 Operadores Podemos usar operadores: igual == diferente != x ou y =&gt; x | y x e y =&gt; x &amp; y Então, além de selecionar um parâmetro da variável class, aqui também selecionamos por outro parâmetro da variável sepal_l, usando o operador &amp;. virginica2&lt;- dados[dados$class==&quot;Iris-virginica&quot; &amp; dados$sepal_l&gt;6.5,] virginica2$sepal_l ## [1] 7.1 7.6 7.3 6.7 7.2 6.8 7.7 7.7 6.9 7.7 6.7 7.2 7.2 7.4 7.9 7.7 6.9 6.7 6.9 ## [20] 6.8 6.7 6.7 2.5 Transformação de dados Muitos valores das características tem escalas muito diferentes. Isso pode gerar dificuldades para algoritmos que usam todos esses valores para compor um valor único de comparação. Para resolver isso pode ser utilizada a normalização ou conversão de dados. 2.6 Técnicas de normalização Min-max: altera valores extremos e organiza os internos dentro de um novo intervalo. v’=((v-min(v))/(max(v) - min(v)))*(maxnovo - minnovo) + minnovo Para exemplificar, vamos transformar a variável body_mass_g em uma escala de 0 a 1 e armazenar o resultado em uma nova variável chamada body_norm: maxnovo&lt;-1 minnovo&lt;-0 dados2$body_norm&lt;-NA dados2$body_norm&lt;-((dados2$body_mass_g-(min(dados2$body_mass_g, na.rm = T)))/(max(dados2$body_mass_g,na.rm = T) - (min(dados2$body_mass_g,na.rm = T)))*(maxnovo - minnovo) + minnovo) dados2$body_norm ## [1] 0.29166667 0.30555556 0.15277778 NA 0.20833333 0.26388889 ## [7] 0.25694444 0.54861111 0.21527778 0.43055556 0.16666667 0.27777778 ## [13] 0.13888889 0.30555556 0.47222222 0.27777778 0.20833333 0.50000000 ## [19] 0.17361111 0.41666667 0.19444444 0.25000000 0.30555556 0.34722222 ## [25] 0.30555556 0.30555556 0.23611111 0.13888889 0.12500000 0.34722222 ## [31] 0.15277778 0.33333333 0.16666667 0.33333333 0.17361111 0.40277778 ## [37] 0.34722222 0.23611111 0.16666667 0.54166667 0.12500000 0.33333333 ## [43] 0.11111111 0.47222222 0.08333333 0.52777778 0.20138889 0.07638889 ## [49] 0.20833333 0.40277778 0.22222222 0.44444444 0.20833333 0.37500000 ## [55] 0.05555556 0.27777778 0.23611111 0.30555556 0.04166667 0.29166667 ## [61] 0.12500000 0.47222222 0.25000000 0.37500000 0.04166667 0.34722222 ## [67] 0.18055556 0.38888889 0.09722222 0.48611111 0.25000000 0.33333333 ## [73] 0.23611111 0.40277778 0.27777778 0.43055556 0.27777778 0.33333333 ## [79] 0.23611111 0.36111111 0.13888889 0.55555556 0.30555556 0.41666667 ## [85] 0.18055556 0.23611111 0.30555556 0.22222222 0.34722222 0.25000000 ## [91] 0.23611111 0.44444444 0.19444444 0.48611111 0.16666667 0.44444444 ## [97] 0.27777778 0.45833333 0.05555556 0.38888889 0.28472222 0.56250000 ## [103] 0.10416667 0.43055556 0.06250000 0.23611111 0.29166667 0.33333333 ## [109] 0.13194444 0.57638889 0.31250000 0.52777778 0.13888889 0.43750000 ## [115] 0.33333333 0.38194444 0.05555556 0.29861111 0.18055556 0.17361111 ## [121] 0.12500000 0.22222222 0.20833333 0.32638889 0.09722222 0.36111111 ## [127] 0.15972222 0.44444444 0.09722222 0.36111111 0.17361111 0.22222222 ## [133] 0.22222222 0.49305556 0.20138889 0.33333333 0.13194444 0.35416667 ## [139] 0.19444444 0.43055556 0.19444444 0.21527778 0.09722222 0.28472222 ## [145] 0.08333333 0.26388889 0.43055556 0.21527778 0.20833333 0.29166667 ## [151] 0.27777778 0.36111111 0.50000000 0.83333333 0.48611111 0.83333333 ## [157] 0.75000000 0.51388889 0.58333333 0.69444444 0.47222222 0.68055556 ## [163] 0.54166667 0.79166667 0.54166667 0.87500000 0.41666667 0.87500000 ## [169] 0.40277778 1.00000000 0.58333333 0.73611111 0.83333333 0.63888889 ## [175] 0.47222222 0.65277778 0.63888889 0.66666667 0.38888889 0.81944444 ## [181] 0.52777778 0.79166667 0.70833333 0.55555556 0.65277778 0.93055556 ## [187] 0.68055556 0.75000000 0.62500000 0.70833333 0.45833333 0.73611111 ## [193] 0.34722222 0.83333333 0.44444444 0.56944444 0.79166667 0.61111111 ## [199] 0.41666667 0.75000000 0.66666667 0.72222222 0.59722222 0.72222222 ## [205] 0.47222222 0.63888889 0.61111111 0.65277778 0.44444444 0.63888889 ## [211] 0.48611111 0.79166667 0.41666667 0.72222222 0.47222222 0.81944444 ## [217] 0.55555556 0.83333333 0.54166667 0.86111111 0.55555556 0.79166667 ## [223] 0.56944444 0.63888889 0.66666667 0.69444444 0.55555556 0.86111111 ## [229] 0.52777778 0.91666667 0.56944444 0.90277778 0.53472222 0.76388889 ## [235] 0.56250000 0.73611111 0.56944444 0.80555556 0.52777778 0.72222222 ## [241] 0.60416667 0.79166667 0.62500000 0.75000000 0.56944444 0.81944444 ## [247] 0.59722222 0.69444444 0.61805556 0.60416667 0.53472222 0.70833333 ## [253] 0.59722222 0.80555556 0.63194444 0.77777778 0.56250000 0.77777778 ## [259] 0.55555556 0.77777778 0.52083333 0.77777778 0.63888889 0.90277778 ## [265] 0.54166667 0.77777778 0.46527778 0.87500000 0.60416667 0.91666667 ## [271] 0.61805556 NA 0.59722222 0.84722222 0.69444444 0.75000000 ## [277] 0.22222222 0.33333333 0.26388889 0.22916667 0.28472222 0.34722222 ## [283] 0.15277778 0.29166667 0.40277778 0.27777778 0.30555556 0.29861111 ## [289] 0.27777778 0.37500000 0.24305556 0.37500000 0.16666667 0.27777778 ## [295] 0.20833333 0.47222222 0.25000000 0.19444444 0.05555556 0.30555556 ## [301] 0.16666667 0.40277778 0.19444444 0.30555556 0.27777778 0.51388889 ## [307] 0.13888889 0.44444444 0.18055556 0.38888889 0.25000000 0.33333333 ## [313] 0.31944444 0.58333333 0.00000000 0.50000000 0.34722222 0.26388889 ## [319] 0.23611111 0.22222222 0.27083333 0.48611111 0.19444444 0.44444444 ## [325] 0.15277778 0.27083333 0.17361111 0.34722222 0.25000000 0.37500000 ## [331] 0.18055556 0.20833333 0.15277778 0.37500000 0.30555556 0.22916667 ## [337] 0.34722222 0.26388889 0.26388889 0.36111111 0.19444444 0.29861111 ## [343] 0.38888889 0.29861111 hist(dados2$body_norm) Outra opção é o Z-score, no qual os valores são reorganizados pela média e desvio-padrão do conjunto original: v1=(v - média(v))/desvio padrão (v) Vamos usar a mesma variável e transformar para Z-score: dados2$body_norm2&lt;-NA dados2$body_norm2&lt;-(dados2$body_mass_g - mean(dados2$body_mass_g, na.rm = T))/sd(dados2$body_mass_g, na.rm=T) dados2$body_norm2 ## [1] -0.563316704 -0.500969030 -1.186793445 NA -0.937402749 ## [6] -0.688012052 -0.719185889 0.590115266 -0.906228912 0.060160036 ## [11] -1.124445771 -0.625664378 -1.249141119 -0.500969030 0.247203059 ## [16] -0.625664378 -0.937402749 0.371898407 -1.093271934 -0.002187638 ## [21] -0.999750423 -0.750359726 -0.500969030 -0.313926008 -0.500969030 ## [26] -0.500969030 -0.812707400 -1.249141119 -1.311488793 -0.313926008 ## [31] -1.186793445 -0.376273682 -1.124445771 -0.376273682 -1.093271934 ## [36] -0.064535312 -0.313926008 -0.812707400 -1.124445771 0.558941429 ## [41] -1.311488793 -0.376273682 -1.373836467 0.247203059 -1.498531815 ## [46] 0.496593755 -0.968576586 -1.529705652 -0.937402749 -0.064535312 ## [51] -0.875055074 0.122507710 -0.937402749 -0.189230660 -1.623227163 ## [56] -0.625664378 -0.812707400 -0.500969030 -1.685574837 -0.563316704 ## [61] -1.311488793 0.247203059 -0.750359726 -0.189230660 -1.685574837 ## [66] -0.313926008 -1.062098097 -0.126882986 -1.436184141 0.309550733 ## [71] -0.750359726 -0.376273682 -0.812707400 -0.064535312 -0.625664378 ## [76] 0.060160036 -0.625664378 -0.376273682 -0.812707400 -0.251578334 ## [81] -1.249141119 0.621289103 -0.500969030 -0.002187638 -1.062098097 ## [86] -0.812707400 -0.500969030 -0.875055074 -0.313926008 -0.750359726 ## [91] -0.812707400 0.122507710 -0.999750423 0.309550733 -1.124445771 ## [96] 0.122507710 -0.625664378 0.184855384 -1.623227163 -0.126882986 ## [101] -0.594490541 0.652462940 -1.405010304 0.060160036 -1.592053326 ## [106] -0.812707400 -0.563316704 -0.376273682 -1.280314956 0.714810614 ## [111] -0.469795193 0.496593755 -1.249141119 0.091333873 -0.376273682 ## [116] -0.158056823 -1.623227163 -0.532142867 -1.062098097 -1.093271934 ## [121] -1.311488793 -0.875055074 -0.937402749 -0.407447519 -1.436184141 ## [126] -0.251578334 -1.155619608 0.122507710 -1.436184141 -0.251578334 ## [131] -1.093271934 -0.875055074 -0.875055074 0.340724570 -0.968576586 ## [136] -0.376273682 -1.280314956 -0.282752171 -0.999750423 0.060160036 ## [141] -0.999750423 -0.906228912 -1.436184141 -0.594490541 -1.498531815 ## [146] -0.688012052 0.060160036 -0.906228912 -0.937402749 -0.563316704 ## [151] -0.625664378 -0.251578334 0.371898407 1.868242584 0.309550733 ## [156] 1.868242584 1.494156540 0.434246081 0.745984451 1.244765843 ## [161] 0.247203059 1.182418169 0.558941429 1.681199562 0.558941429 ## [166] 2.055285606 -0.002187638 2.055285606 -0.064535312 2.616414673 ## [171] 0.745984451 1.431808866 1.868242584 0.995375147 0.247203059 ## [176] 1.057722821 0.995375147 1.120070495 -0.126882986 1.805894910 ## [181] 0.496593755 1.681199562 1.307113518 0.621289103 1.057722821 ## [186] 2.304676302 1.182418169 1.494156540 0.933027473 1.307113518 ## [191] 0.184855384 1.431808866 -0.313926008 1.868242584 0.122507710 ## [196] 0.683636777 1.681199562 0.870679799 -0.002187638 1.494156540 ## [201] 1.120070495 1.369461192 0.808332125 1.369461192 0.247203059 ## [206] 0.995375147 0.870679799 1.057722821 0.122507710 0.995375147 ## [211] 0.309550733 1.681199562 -0.002187638 1.369461192 0.247203059 ## [216] 1.805894910 0.621289103 1.868242584 0.558941429 1.992937932 ## [221] 0.621289103 1.681199562 0.683636777 0.995375147 1.120070495 ## [226] 1.244765843 0.621289103 1.992937932 0.496593755 2.242328628 ## [231] 0.683636777 2.179980954 0.527767592 1.556504214 0.652462940 ## [236] 1.431808866 0.683636777 1.743547236 0.496593755 1.369461192 ## [241] 0.839505962 1.681199562 0.933027473 1.494156540 0.683636777 ## [246] 1.805894910 0.808332125 1.244765843 0.901853636 0.839505962 ## [251] 0.527767592 1.307113518 0.808332125 1.743547236 0.964201310 ## [256] 1.618851888 0.652462940 1.618851888 0.621289103 1.618851888 ## [261] 0.465419918 1.618851888 0.995375147 2.179980954 0.558941429 ## [266] 1.618851888 0.216029222 2.055285606 0.839505962 2.242328628 ## [271] 0.901853636 NA 0.808332125 1.930590258 1.244765843 ## [276] 1.494156540 -0.875055074 -0.376273682 -0.688012052 -0.843881237 ## [281] -0.594490541 -0.313926008 -1.186793445 -0.563316704 -0.064535312 ## [286] -0.625664378 -0.500969030 -0.532142867 -0.625664378 -0.189230660 ## [291] -0.781533563 -0.189230660 -1.124445771 -0.625664378 -0.937402749 ## [296] 0.247203059 -0.750359726 -0.999750423 -1.623227163 -0.500969030 ## [301] -1.124445771 -0.064535312 -0.999750423 -0.500969030 -0.625664378 ## [306] 0.434246081 -1.249141119 0.122507710 -1.062098097 -0.126882986 ## [311] -0.750359726 -0.376273682 -0.438621356 0.745984451 -1.872617859 ## [316] 0.371898407 -0.313926008 -0.688012052 -0.812707400 -0.875055074 ## [321] -0.656838215 0.309550733 -0.999750423 0.122507710 -1.186793445 ## [326] -0.656838215 -1.093271934 -0.313926008 -0.750359726 -0.189230660 ## [331] -1.062098097 -0.937402749 -1.186793445 -0.189230660 -0.500969030 ## [336] -0.843881237 -0.313926008 -0.688012052 -0.688012052 -0.251578334 ## [341] -0.999750423 -0.532142867 -0.126882986 -0.532142867 hist(dados2$body_norm2) Para identificando o tipo de variável, podemos usar algumas funções: is.numeric(dados2$bill_length_mm) ## [1] TRUE is.numeric(dados2$species) ## [1] FALSE is.factor(dados2$species) ## [1] FALSE is.character(dados2$species) ## [1] TRUE Transformando tipos de variáveis dados2$species&lt;-as.factor(dados2$species) Tem outras opções como as.numeric() e as.matrix() head(dados3) ## bill_length_mm bill_depth_mm flipper_length_mm ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18.0 195 ## 4 NA NA NA ## 5 36.7 19.3 193 ## 6 39.3 20.6 190 dados3&lt;-as.matrix(dados3) is.matrix(dados3) ## [1] TRUE 2.7 Juntar dados (R base) Podemos usar o R para juntar dados de diferentes arquivos. Primeiro vamos carregar alguns dados: dados3&lt;-read.xlsx(&quot;dados/dados_bioq.xlsx&quot;, sheet=1, colNames=T) dados4&lt;-read.xlsx(&quot;dados/dados_bioq.xlsx&quot;, sheet=2, colNames=T) dados5&lt;-read.xlsx(&quot;dados/dados_bioq.xlsx&quot;, sheet=3, colNames=T) Esses dados tem diferentes informações da mesma amostra: head(dados3) ## ID PN RON ## 1 1 71.14 NA ## 2 2 71.54 NA ## 3 3 68.63 86.55 ## 4 4 68.79 86.52 ## 5 5 68.83 86.61 ## 6 6 70.17 NA head(dados4) ## ID atividade ## 1 1 2.47 ## 2 4 3.35 ## 3 5 3.99 ## 4 6 3.24 ## 5 7 3.75 ## 6 9 3.46 head(dados5) ## ID K ## 1 1 GA ## 2 2 &lt;NA&gt; ## 3 3 &lt;NA&gt; ## 4 4 GG ## 5 5 GA ## 6 6 AA Juntando os dados3 e dados4: dados6&lt;-merge.data.frame(dados3, dados4, by.x = &quot;ID&quot;, by.y = &quot;ID&quot;) head(dados6) ## ID PN RON atividade ## 1 1 71.14 NA 2.47 ## 2 4 68.79 86.52 3.35 ## 3 5 68.83 86.61 3.99 ## 4 6 70.17 NA 3.24 ## 5 7 74.75 NA 3.75 ## 6 9 71.07 88.07 3.46 Em dados6 tem as amostras que estão presentes em dados3 e também em dados4. Juntando o objeto resultante com dados5: dados7&lt;-merge.data.frame(dados6, dados5, by.x = &quot;ID&quot;, by.y = &quot;ID&quot;) head(dados7) ## ID PN RON atividade K ## 1 1 71.14 NA 2.47 GA ## 2 4 68.79 86.52 3.35 GG ## 3 5 68.83 86.61 3.99 GA ## 4 6 70.17 NA 3.24 AA ## 5 7 74.75 NA 3.75 &lt;NA&gt; ## 6 9 71.07 88.07 3.46 GA Mas também podemos manter apenas os dados de um ou outro objeto: dados8&lt;-merge.data.frame(dados6, dados5, by.x = &quot;ID&quot;, by.y = &quot;ID&quot;, all.x = T) head(dados8) ## ID PN RON atividade K ## 1 1 71.14 NA 2.47 GA ## 2 4 68.79 86.52 3.35 GG ## 3 5 68.83 86.61 3.99 GA ## 4 6 70.17 NA 3.24 AA ## 5 7 74.75 NA 3.75 &lt;NA&gt; ## 6 9 71.07 88.07 3.46 GA dados9&lt;-merge.data.frame(dados6, dados5, by.x = &quot;ID&quot;, by.y = &quot;ID&quot;, all.y = T) head(dados9) ## ID PN RON atividade K ## 1 1 71.14 NA 2.47 GA ## 2 2 NA NA NA &lt;NA&gt; ## 3 3 NA NA NA &lt;NA&gt; ## 4 4 68.79 86.52 3.35 GG ## 5 5 68.83 86.61 3.99 GA ## 6 6 70.17 NA 3.24 AA Ou ainda manter todas as amostras dos 2 objetos dados10&lt;-merge.data.frame(dados6, dados5, by.x = &quot;ID&quot;, by.y = &quot;ID&quot;, all.x = T, all.y = T) head(dados10) ## ID PN RON atividade K ## 1 1 71.14 NA 2.47 GA ## 2 2 NA NA NA &lt;NA&gt; ## 3 3 NA NA NA &lt;NA&gt; ## 4 4 68.79 86.52 3.35 GG ## 5 5 68.83 86.61 3.99 GA ## 6 6 70.17 NA 3.24 AA "],["o-sistema-tidyverse.html", "Capítulo 3 O sistema tidyverse 3.1 Manipulação de dados com tidyverse 3.2 Função filter 3.3 Função arrange 3.4 Função select 3.5 Função mutate e transmutate 3.6 Funções group_by e summarise 3.7 Funções pull e distinct 3.8 Pipes 3.9 Pipe nativa do R 3.10 Tibble 3.11 Juntar dados", " Capítulo 3 O sistema tidyverse Tidyverse é um conjunto de pacotes para ciência de dados. Quando instalamos o pacote tidyverse ele faz a instalação de vários pacotes relacionados: ggplot2, tibble, tidyr, readr, purrr, dplyr library(tidyverse) Carregando os dados: dados&lt;-read.table(&quot;dados/iris.txt&quot;, head=T, sep = &quot;,&quot;) O R possui muitos dados disponíveis. Podemos carregar esses dados com a função data(). Esse arquivo iris pode ser carregado dessa maneira. 3.1 Manipulação de dados com tidyverse Tem várias funções para manipular os dados, entre elas: Selecionar casos por seus valores (filter()). Reordenar as linhas (arrange()). Selecionar variáveis pelo nome (select()). Criar novas variáveis (mutate()). Colapsar valores em um resumo (summarise()). 3.2 Função filter Definimos o objeto e depois a(s) variável(is). Nesse exemplo abaixo, filtramos os casos (linhas) em que class é igual a Iris-setosa e que sepal_w seja maior que 3.1: setosa&lt;-filter(dados, class==&quot;Iris-setosa&quot; &amp; sepal_w &gt; 3.1) head(setosa) ## sepal_l sepal_w petal_l petal_w class ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.7 3.2 1.3 0.2 Iris-setosa ## 3 5.0 3.6 1.4 0.2 Iris-setosa ## 4 5.4 3.9 1.7 0.4 Iris-setosa ## 5 4.6 3.4 1.4 0.3 Iris-setosa ## 6 5.0 3.4 1.5 0.2 Iris-setosa 3.3 Função arrange Com a função arrange podemos ordenar os dados, de forma crescente (default) ou descrescente (adicionando desc), por ou mais variáveis. ordenado&lt;-arrange(dados, desc(sepal_l)) ordenado&lt;-arrange(dados, desc(sepal_l), desc(sepal_w)) head(ordenado) ## sepal_l sepal_w petal_l petal_w class ## 1 7.9 3.8 6.4 2.0 Iris-virginica ## 2 7.7 3.8 6.7 2.2 Iris-virginica ## 3 7.7 3.0 6.1 2.3 Iris-virginica ## 4 7.7 2.8 6.7 2.0 Iris-virginica ## 5 7.7 2.6 6.9 2.3 Iris-virginica ## 6 7.6 3.0 6.6 2.1 Iris-virginica 3.4 Função select Com a função select podemos selecionar variáveis (colunas). Podemos especificar uma coluna ou várias colunas. head(dados) ## sepal_l sepal_w petal_l petal_w class ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.9 3.0 1.4 0.2 Iris-setosa ## 3 4.7 3.2 1.3 0.2 Iris-setosa ## 4 4.6 3.1 1.5 0.2 Iris-setosa ## 5 5.0 3.6 1.4 0.2 Iris-setosa ## 6 5.4 3.9 1.7 0.4 Iris-setosa dados2&lt;-select(dados, petal_w ) head(dados2) ## petal_w ## 1 0.2 ## 2 0.2 ## 3 0.2 ## 4 0.2 ## 5 0.2 ## 6 0.4 3.5 Função mutate e transmutate A função mutate cria uma nova coluna. A nova coluna será adicionada ao final do objeto. Com a função transmutate, o objeto terá apenas a(s) nova(s) coluna(s). No exemplo abaixo, foram criadas 2 novas colunas, indice e indice2. O conteúdo dessas novas colunas será a multiplicação dos valores de outras variáveis. dados3&lt;-mutate(dados, indice=sepal_l*sepal_w, indice2=petal_l*petal_w) head(dados3) ## sepal_l sepal_w petal_l petal_w class indice indice2 ## 1 5.1 3.5 1.4 0.2 Iris-setosa 17.85 0.28 ## 2 4.9 3.0 1.4 0.2 Iris-setosa 14.70 0.28 ## 3 4.7 3.2 1.3 0.2 Iris-setosa 15.04 0.26 ## 4 4.6 3.1 1.5 0.2 Iris-setosa 14.26 0.30 ## 5 5.0 3.6 1.4 0.2 Iris-setosa 18.00 0.28 ## 6 5.4 3.9 1.7 0.4 Iris-setosa 21.06 0.68 3.6 Funções group_by e summarise Essas duas funções são muito úteis quando usadas em conjunto. Na função group_by, especificamos o objeto e uma variável categórica. Em summarise podemos usar uma função como mean, assim teremos a média da variável especificada, separada pela variável categórica usada em group_by: dados4&lt;-group_by(dados, class) dados4&lt;-summarise(dados4, sepala=mean(sepal_l)) head(dados4) ## # A tibble: 3 × 2 ## class sepala ## &lt;chr&gt; &lt;dbl&gt; ## 1 Iris-setosa 5.01 ## 2 Iris-versicolor 5.94 ## 3 Iris-virginica 6.59 3.7 Funções pull e distinct Para extrair uma coluna em forma de vetor: x&lt;-pull(dados,sepal_l) x ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 Remove linhas com valores repetidos: y&lt;-distinct(dados,sepal_l) head(y) ## sepal_l ## 1 5.1 ## 2 4.9 ## 3 4.7 ## 4 4.6 ## 5 5.0 ## 6 5.4 Se quiser manter todas as colunas: y&lt;-distinct(dados,sepal_l,.keep_all = T) 3.8 Pipes Pipes (%&gt;%) é uma ferramenta poderosa para expressar claramente uma sequência de várias operações. Está disponível nos pacotes do sistema tidyverse. dados5&lt;-dados%&gt;% filter(class==&quot;Iris-setosa&quot;)%&gt;% mutate(indice=sepal_l*sepal_w)%&gt;% arrange(indice) head(dados5) ## sepal_l sepal_w petal_l petal_w class indice ## 1 4.5 2.3 1.3 0.3 Iris-setosa 10.35 ## 2 4.4 2.9 1.4 0.2 Iris-setosa 12.76 ## 3 4.3 3.0 1.1 0.1 Iris-setosa 12.90 ## 4 4.4 3.0 1.3 0.2 Iris-setosa 13.20 ## 5 4.4 3.2 1.3 0.2 Iris-setosa 14.08 ## 6 4.6 3.1 1.5 0.2 Iris-setosa 14.26 3.9 Pipe nativa do R A partir da versão 4.1.0 tem uma versão nativa do R de pipes: |&gt; 3.10 Tibble Uma tibble é semelhante ao data frame. Pode converter um data frame em tibble assim: head(dados) ## sepal_l sepal_w petal_l petal_w class ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.9 3.0 1.4 0.2 Iris-setosa ## 3 4.7 3.2 1.3 0.2 Iris-setosa ## 4 4.6 3.1 1.5 0.2 Iris-setosa ## 5 5.0 3.6 1.4 0.2 Iris-setosa ## 6 5.4 3.9 1.7 0.4 Iris-setosa dados&lt;- as_tibble(dados) head(dados) ## # A tibble: 6 × 5 ## sepal_l sepal_w petal_l petal_w class ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.9 3 1.4 0.2 Iris-setosa ## 3 4.7 3.2 1.3 0.2 Iris-setosa ## 4 4.6 3.1 1.5 0.2 Iris-setosa ## 5 5 3.6 1.4 0.2 Iris-setosa ## 6 5.4 3.9 1.7 0.4 Iris-setosa Uma das principais diferenças entre tibbles e data frames é que tibbles não convertem automaticamente colunas de texto em fatores. Isso significa que você pode ver os dados exatamente como eles estão armazenados, o que pode ser útil para depurar e analisar dados. Outra diferença entre tibbles e data frames é que tibbles imprimem com mais linhas e colunas do que cabem na tela. Isso torna mais fácil ver todos os dados em um tibble de uma só vez, sem ter que rolar para cima e para baixo. Por fim, tibbles incluem algumas estatísticas básicas sobre cada coluna, como a média, a mediana e o desvio padrão. Isso pode ser útil para obter uma visão geral rápida dos dados em um tibble. 3.11 Juntar dados Juntar dados de diferentes planilhas é uma coisa muito útil, muitas vezes temos diversas planilhas com diferentes informações dos mesmos dados. Juntar esses dados é muito fácil, contanto que tenhamos uma coluna de identificação. No pacote dplyr temos as seguintes funções: inner_join - Uma junção interna combina pares de observações sempre que suas chaves são iguais left_join - mantém todas as observações em x. right_join - mantém todas as observações em y. full_join - mantém todas as observações em x e y. Tem outras funções interessantes, como recode e case_when(), para saber mais consulte Wickham, Çetinkaya-Rundel, and Grolemund (2023) References "],["gráficos.html", "Capítulo 4 Gráficos 4.1 Gráficos com o pacote graphics (R base) 4.2 O pacote ggplot2 4.3 Outros pacotes gráficos", " Capítulo 4 Gráficos O R permite fazer qualquer tipo de gráfico, os quais podem ser personalizados e salvos em diversos formatos e resoluções. Existem muitos pacotes gráficos no R e nesse capítulo vamos ver alguns deles. 4.1 Gráficos com o pacote graphics (R base) 4.1.1 Introdução aos gráficos do R Quando instalamos o R, já temos um pacote para gráficos (graphics) e com ele podemos fazer e personalizar os principais tipos de gráficos. Vamos começar carregando os dados. Usaremos o arquivo iris e vamos criar um gráfico de dispersão com as variáveis comprimento e largura das sépalas. dados&lt;-read.table(&quot;dados/iris.txt&quot;, head=T, sep = &quot;,&quot;) head(dados) ## sepal_l sepal_w petal_l petal_w class ## 1 5.1 3.5 1.4 0.2 Iris-setosa ## 2 4.9 3.0 1.4 0.2 Iris-setosa ## 3 4.7 3.2 1.3 0.2 Iris-setosa ## 4 4.6 3.1 1.5 0.2 Iris-setosa ## 5 5.0 3.6 1.4 0.2 Iris-setosa ## 6 5.4 3.9 1.7 0.4 Iris-setosa plot(dados$sepal_l,dados$sepal_w) Podemos usar mais parâmetros, como type. p: Points. l: Lines. b: Both. c: The lines part alone of b o: Both “overplotted” h: Histogram like (or high-density) vertical lines. n: No plotting. x&lt;-c(1:10) y&lt;-c(3,7,15,8,10,21,19,12,6,10) plot(x,y,type=&quot;l&quot;) plot(x,y,type=&quot;b&quot;) Podemos mudar o padrão dos pontos com pch Os valores vão de 0 a 25: plot(dados$sepal_l,dados$sepal_w, pch=19) 4.1.2 Salvar Para salvar um gráfico podemos clicar na opção export, na janela Plots do RStudio ou podemos fazer assim: png(file=&quot;figura1.png&quot;, units=&quot;in&quot;, res = 300, width = 5,height = 5) plot(dados$sepal_l,dados$sepal_w) dev.off() ## png ## 2 As opções de units são: px, in, cm ou mm. Também podemos salvar em outros formatos como jpg ou tif. Para entender as questões de tamanho e resolução de imagem, consulte: https://pixelcalculator.com/en É possível fazer vários gráficos na mesma janela usando par() e mfrow(). Para um arranjo 2 por 2: par(mfrow=c(2,2)) plot(dados$sepal_l,dados$sepal_w) plot(dados$petal_l,dados$petal_w) plot(dados$sepal_l,dados$petal_w) plot(dados$sepal_w,dados$petal_l) Para voltar ao normal: par(mfrow=c(1,1)) plot(dados$sepal_l,dados$sepal_w) Personalizando o gráfico Podemos usar vários parâmetros para dar nome ao gráficos e aos eixos, especificar as cores, etc. plot(dados$sepal_l,dados$sepal_w, xlab=&quot;Nome eixo X&quot;, ylab=&quot;Nome eixo Y&quot;, main=&quot;Título do gráfico&quot;, xlim=c(3,9),#limites do eixo x ylim=c(1,6),#limites do eixo y col=&quot;darkmagenta&quot;,#cor dos pontos pch=22,#formato dos pontos bg=&quot;darkolivegreen&quot;,#cor de preenchimento tcl=0.4,#tamanho dos traços dos eixos las=1,#orientação dos valores nos eixos: 0,1,2,3 cex=1.5,#tamanho do ponto bty=&quot;n&quot;)#altera as bordas: &quot;o&quot; (default), #&quot;l&quot;, &quot;7&quot;, &quot;c&quot;, &quot;u&quot;, or &quot;]&quot; . &quot;n&quot; suppresses the box. O gráfico pode ficar mais informativo: dados$class&lt;-as.factor(dados$class) plot(dados$sepal_l,dados$sepal_w, col = dados$class) Colocando legenda das cores: dados$class&lt;-as.factor(dados$class) plot(dados$sepal_l,dados$sepal_w, col = dados$class) legend(&#39;topright&#39;, col=unique(dados$class), legend=levels(dados$class), pch =1) Se quiser especificar as cores: plot(dados$sepal_l,dados$sepal_w, col = c(&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;)[as.numeric(dados$class)]) Brincando com as cores: val &lt;- dados$sepal_l + dados$sepal_w maxnovo&lt;-1 minnovo&lt;-0 valcol&lt;-((val-min(val))/(max(val) - min(val)))*(maxnovo - minnovo) + minnovo plot(dados$sepal_l,dados$sepal_w, pch = 15, col = gray(valcol)) Podemos explorar os dados: pairs(dados) Acrescentando cor por espécie: pairs(dados,col = dados$class) 4.1.3 Histogramas Para fazer um histograma usamos a função hist. hist(dados$sepal_l) Também podemos personalizar o histograma: hist(dados$sepal_l, main=&quot;Folha&quot;, xlab=&quot;comprimento sépala&quot;, ylab=&quot;Frequência&quot;, col=c(&quot;gold4&quot;,&quot;darkseagreen4&quot;), border=&quot;black&quot;, adj=0, #alinhamento do texto col.axis=&quot;forestgreen&quot;)#cor do texto nos eixos 4.1.4 Boxplot Outro tipo de gráfico bastante usado é o boxplot boxplot(dados$sepal_l ~ dados$class, main=&quot;Sépalas&quot;, names= c(&quot;Iris-setosa&quot;,&quot;Iris-versicolor&quot;,&quot;Iris-virginica&quot;),xlab=&quot;espécies&quot;, ylab=&quot;comprimento&quot;) Podemos personalizar o boxplot: boxplot(dados$sepal_l ~ dados$class, main=&quot;Sépalas&quot;, names= c(&quot;Iris-setosa&quot;,&quot;Iris-versicolor&quot;,&quot;Iris-virginica&quot;),xlab=&quot;espécies&quot;, ylab=&quot;comprimento&quot;, notch=T, col=c(&quot;brown1&quot;,&quot;khaki1&quot;, &quot;blue&quot;)) As cores podem ser especificadas pelo nome da cor ou pelo código hex. Os nomes e os códigos podem ser encontrados em vários sites como: http://www.sthda.com/english/wiki/colors-in-r http://sape.inf.usi.ch/quick-reference/ggplot2/colour 4.1.5 Barplot Também temos o gráfico de barras. Embora tenha semelhamças com o histograma, os histogramas são barras conectadas umas às outras, visualizando a distribuição de uma variável quantitativa contínua e os gráficos de barras usam retângulos de tamanho proporcional para visualizar algum tipo de dados categóricos. Podemos criar uma tabela de frequência com a função table e usar o resultado para criar um gráfico de barras: x&lt;-table(dados$class) barplot(x, col = c(&quot;brown1&quot;,&quot;khaki1&quot;, &quot;blue&quot;)) 4.2 O pacote ggplot2 O pacote ggplot2 é um dos principais pacotes gráficos do R. Os elementos de um gráfico (dados, sistema de coordenadas, rótulos, anotações, entre outros) são as camadas e a construção de um gráfico se dá pela sobreposição dessas camadas. 4.2.1 Gráficos de pontos (dispersão) library(ggplot2) ggplot(dados) + geom_point(aes(sepal_l, sepal_w)) A primeira camada é dada pela função ggplot() e recebe a nossos dados; A segunda camada é dada pela função geom_point(), especificando a forma geométrica utilizada no mapeamento das observações (pontos); As camadas são unidas com um +; O mapeamento na função geom_point() recebe a função aes(), responsável por descrever como as variáveis serão mapeadas nos aspectos visuais dos pontos (a forma geométrica escolhida); Neste caso, os aspectos visuais mapeados são a posição do ponto no eixo x e a posição do ponto no eixo y; Podemos usar pipes: library(dplyr) dados%&gt;% ggplot() + geom_point(aes(x = sepal_l, y = sepal_w)) # obs: não precisamos colocar x e y Podemos criar um objeto ggplot e depois adicionar camadas: p &lt;- ggplot(dados) p + geom_point(aes(sepal_l, sepal_w,color= class))+ labs(title=&quot;Iris&quot;, x = &quot;Comprimento das sépalas&quot;, y = &quot;Largura das sépalas&quot;, color = &quot;Espécies&quot;) Também podemos alterar o tamanho: p + geom_point(aes(sepal_l, sepal_w, size= class)) Podemos adicionar mais camadas: p + geom_point(aes(sepal_l, sepal_w, color= class))+ facet_wrap(~class) 4.2.2 Salvar Para salvar usamos a função ggsave, que vai salvar o último gráfico gerado: ggsave( &quot;figura.jpg&quot;, plot = last_plot(), dpi = 300, ) ## Saving 7 x 5 in image Vamos carregar outra planilha de dados: library(openxlsx) dados2&lt;-read.xlsx(&quot;dados/Data_Cortex_Nuclear.xlsx&quot;, sheet = 1, colNames = T) head(dados2) ## MouseID DYRK1A_N ITSN1_N BDNF_N NR1_N NR2A_N pAKT_N pBRAF_N ## 1 309_1 0.5036439 0.7471932 0.4301753 2.816329 5.990152 0.2188300 0.1775655 ## 2 309_2 0.5146171 0.6890635 0.4117703 2.789514 5.685038 0.2116362 0.1728170 ## 3 309_3 0.5091831 0.7302468 0.4183088 2.687201 5.622059 0.2090109 0.1757222 ## 4 309_4 0.4421067 0.6170762 0.3586263 2.466947 4.979503 0.2228858 0.1764626 ## 5 309_5 0.4349402 0.6174298 0.3588022 2.365785 4.718679 0.2131059 0.1736270 ## 6 309_6 0.4475064 0.6281758 0.3673881 2.385939 4.807635 0.2185778 0.1762334 ## pCAMKII_N pCREB_N pELK_N pERK_N pJNK_N PKCA_N pMEK_N ## 1 2.373744 0.2322238 1.750936 0.6879062 0.3063817 0.4026984 0.2969273 ## 2 2.292150 0.2269721 1.596377 0.6950062 0.2990511 0.3859868 0.2813189 ## 3 2.283337 0.2302468 1.561316 0.6773484 0.2912761 0.3810025 0.2817103 ## 4 2.152301 0.2070042 1.595086 0.5832768 0.2967287 0.3770870 0.3138320 ## 5 2.134014 0.1921579 1.504230 0.5509601 0.2869612 0.3635021 0.2779643 ## 6 2.141282 0.1951875 1.442398 0.5663396 0.2898239 0.3638930 0.2668369 ## pNR1_N pNR2A_N pNR2B_N pPKCAB_N pRSK_N AKT_N BRAF_N CAMKII_N ## 1 1.0220603 0.6056726 1.877684 2.308745 0.4415994 0.8593658 0.4162891 0.3696080 ## 2 0.9566759 0.5875587 1.725774 2.043037 0.4452219 0.8346593 0.4003642 0.3561775 ## 3 1.0036350 0.6024488 1.731873 2.017984 0.4676679 0.8143294 0.3998469 0.3680888 ## 4 0.8753903 0.5202932 1.566852 2.132754 0.4776707 0.7277046 0.3856387 0.3629700 ## 5 0.8649120 0.5079898 1.480059 2.013697 0.4834161 0.6877937 0.3675305 0.3553109 ## 6 0.8591209 0.5213066 1.538244 1.968275 0.4959000 0.6724022 0.3694045 0.3571717 ## CREB_N ELK_N ERK_N GSK3B_N JNK_N MEK_N TRKA_N RSK_N ## 1 0.1789443 1.866358 3.685247 1.537227 0.2645263 0.3196770 0.8138665 0.1658460 ## 2 0.1736797 1.761047 3.485287 1.509249 0.2557270 0.3044187 0.7805042 0.1571935 ## 3 0.1739047 1.765544 3.571456 1.501244 0.2596135 0.3117467 0.7851540 0.1608954 ## 4 0.1794489 1.286277 2.970137 1.419710 0.2595358 0.2792181 0.7344917 0.1622099 ## 5 0.1748355 1.324695 2.896334 1.359876 0.2507050 0.2736672 0.7026991 0.1548274 ## 6 0.1797285 1.227450 2.956983 1.447910 0.2508402 0.2840436 0.7043958 0.1568759 ## APP_N Bcatenin_N SOD1_N MTOR_N P38_N pMTOR_N DSCR1_N ## 1 0.4539098 3.037621 0.3695096 0.4585385 0.3353358 0.8251920 0.5769155 ## 2 0.4309403 2.921882 0.3422793 0.4235599 0.3248347 0.7617176 0.5450973 ## 3 0.4231873 2.944136 0.3436962 0.4250048 0.3248517 0.7570308 0.5436197 ## 4 0.4106149 2.500204 0.3445093 0.4292113 0.3301208 0.7469798 0.5467626 ## 5 0.3985498 2.456560 0.3291258 0.4087552 0.3134148 0.6919565 0.5368605 ## 6 0.3910472 2.467133 0.3275978 0.4044899 0.2962764 0.6744186 0.5397231 ## AMPKA_N NR2B_N pNUMB_N RAPTOR_N TIAM1_N pP70S6_N NUMB_N ## 1 0.4480993 0.5862714 0.3947213 0.3395706 0.4828639 0.2941698 0.1821505 ## 2 0.4208761 0.5450973 0.3682546 0.3219592 0.4545193 0.2764306 0.1820863 ## 3 0.4046298 0.5529941 0.3638799 0.3130859 0.4471972 0.2566482 0.1843877 ## 4 0.3868603 0.5478485 0.3667707 0.3284919 0.4426497 0.3985340 0.1617677 ## 5 0.3608164 0.5128240 0.3515510 0.3122063 0.4190949 0.3934470 0.1602002 ## 6 0.3542143 0.5143164 0.3472241 0.3031321 0.4128243 0.3825783 0.1623303 ## P70S6_N pGSK3B_N pPKCG_N CDK5_N S6_N ADARB1_N AcetylH3K9_N ## 1 0.8427252 0.1926084 1.443091 0.2947000 0.3546045 1.339070 0.1701188 ## 2 0.8476146 0.1948153 1.439460 0.2940598 0.3545483 1.306323 0.1714271 ## 3 0.8561658 0.2007373 1.524364 0.3018807 0.3860868 1.279600 0.1854563 ## 4 0.7602335 0.1841694 1.612382 0.2963818 0.2906795 1.198765 0.1597991 ## 5 0.7681129 0.1857183 1.645807 0.2968294 0.3093450 1.206995 0.1646503 ## 6 0.7796946 0.1867930 1.634615 0.2880373 0.3323671 1.123445 0.1756929 ## RRP1_N BAX_N ARC_N ERBB4_N nNOS_N Tau_N GFAP_N ## 1 0.1591024 0.1888517 0.1063052 0.1449893 0.1766677 0.1251904 0.1152909 ## 2 0.1581289 0.1845700 0.1065922 0.1504709 0.1783090 0.1342751 0.1182345 ## 3 0.1486963 0.1905322 0.1083031 0.1453302 0.1762129 0.1325604 0.1177602 ## 4 0.1661123 0.1853235 0.1031838 0.1406558 0.1638042 0.1232096 0.1174394 ## 5 0.1606870 0.1882214 0.1047838 0.1419830 0.1677096 0.1368377 0.1160478 ## 6 0.1505939 0.1838235 0.1064762 0.1395645 0.1748445 0.1305147 0.1152432 ## GluR3_N GluR4_N IL1B_N P3525_N pCASP9_N PSD95_N SNCA_N ## 1 0.2280435 0.1427556 0.4309575 0.2475378 1.603310 2.014875 0.1082343 ## 2 0.2380731 0.1420366 0.4571562 0.2576322 1.671738 2.004605 0.1097485 ## 3 0.2448173 0.1424450 0.5104723 0.2553430 1.663550 2.016831 0.1081962 ## 4 0.2349467 0.1450682 0.4309959 0.2511031 1.484624 1.957233 0.1198832 ## 5 0.2555277 0.1408705 0.4812265 0.2517730 1.534835 2.009109 0.1195244 ## 6 0.2368495 0.1364536 0.4785775 0.2444853 1.507777 2.003535 0.1206872 ## Ubiquitin_N pGSK3B_Tyr216_N SHH_N BAD_N BCL2_N pS6_N pCFOS_N ## 1 1.0449792 0.8315565 0.1888517 0.1226520 NA 0.1063052 0.1083359 ## 2 1.0098831 0.8492704 0.2004036 0.1166822 NA 0.1065922 0.1043154 ## 3 0.9968476 0.8467087 0.1936845 0.1185082 NA 0.1083031 0.1062193 ## 4 0.9902247 0.8332768 0.1921119 0.1327812 NA 0.1031838 0.1112620 ## 5 0.9977750 0.8786678 0.2056042 0.1299541 NA 0.1047838 0.1106939 ## 6 0.9201782 0.8436793 0.1904695 0.1315752 NA 0.1064762 0.1094457 ## SYP_N H3AcK18_N EGR1_N H3MeK4_N CaNA_N Genotype Treatment Behavior ## 1 0.4270992 0.1147832 0.1317900 0.1281856 1.675652 Control Memantine C/S ## 2 0.4415813 0.1119735 0.1351030 0.1311187 1.743610 Control Memantine C/S ## 3 0.4357769 0.1118829 0.1333618 0.1274311 1.926427 Control Memantine C/S ## 4 0.3916910 0.1304053 0.1474442 0.1469011 1.700563 Control Memantine C/S ## 5 0.4341538 0.1184814 0.1403143 0.1483799 1.839730 Control Memantine C/S ## 6 0.4398331 0.1166572 0.1407664 0.1421804 1.816389 Control Memantine C/S ## class ## 1 c-CS-m ## 2 c-CS-m ## 3 c-CS-m ## 4 c-CS-m ## 5 c-CS-m ## 6 c-CS-m Esses dados podem ser baixados do seguinte endereço: https://archive.ics.uci.edu/dataset/342/mice+protein+expression (Higuera and Cios 2015) Podemos selecionar algumas colunas e criar um objeto ggplot: p &lt;- dados2 %&gt;% select(DYRK1A_N:pAKT_N,Genotype:class)%&gt;% ggplot(aes(DYRK1A_N, ITSN1_N, color = Genotype)) E criar um gráfico de dispersão: p + geom_point(size = 0.7) Podemos mudar as escalas dos eixos x e y. Por exemplo, vamos usar uma escala logarítmica (log na base 10): p + geom_point(size = 1) + scale_x_log10() + scale_y_log10() 4.2.3 Histogramas Criando um objeto ggplot: p &lt;- dados2 %&gt;% ggplot(aes(x = DYRK1A_N)) Histograma básico: p + geom_histogram() Personalizando a cor de preenchimento, cor da linha e legendas: p + geom_histogram(binwidth = 0.1, fill = &quot;blue&quot;, col = &quot;black&quot;) + xlab(&quot;expressão&quot;) + ggtitle(&quot;Histograma&quot;) 4.2.4 Density plot Um gráfico de densidade é uma representação da distribuição de uma variável numérica. É uma versão suavizada do histograma e é usado no mesmo conceito. p + geom_density() Podemos usar cores: p + geom_density(fill = &quot;blue&quot;) Transparência ggplot(dados2, aes(EGR1_N, fill = class, colour = class)) + geom_density(alpha = 0.2, na.rm = TRUE) 4.2.5 Boxplot O boxplot é um gráfico onde a parte central contém os valores que estão entre o primeiro quartil e o terceiro quartil. As hastes inferiores e superiores se estendem, respectivamente, do primeiro quartil até o menor valor, limite inferior, e do terceiro quartil até o maior valor. p &lt;- dados2 %&gt;% ggplot(aes(y = ADARB1_N , group=class, color=class)) p + geom_boxplot() 4.2.6 Gráfico Q-Q O gráfico Q-Q é um gráfico de probabilidades, usado para comparar duas distribuições de probabilidade, traçando seus quantis uns contra os outros. QQ-plot básico no ggplot2: p &lt;- dados2 %&gt;% select(DYRK1A_N:pAKT_N,Genotype:class)%&gt;% filter(Genotype ==&quot;Ts65Dn&quot;)%&gt;% ggplot(aes(sample = DYRK1A_N)) p + geom_qq() Podemos fazer um QQ-plot contra uma distribuição normal com a mesma média e desvio padrão: params &lt;- dados2 %&gt;% select(DYRK1A_N:pAKT_N,Genotype:class)%&gt;% filter(Genotype ==&quot;Ts65Dn&quot;)%&gt;% summarize(mean = mean(DYRK1A_N, na.rm = T), sd = sd(DYRK1A_N, na.rm=T)) p + geom_qq(dparams = params) + geom_abline() 4.2.7 Figura com vários gráficos Para juntar vários gráficos do ggplot2 em uma imagem usamos o pacote gridExtra Vamos primeiro criar os gráficos e armazer em p1, p2, p3: p &lt;- dados2 %&gt;% select(DYRK1A_N:pAKT_N,Genotype:class)%&gt;% ggplot(aes(x = DYRK1A_N)) p1 &lt;- p + geom_histogram(binwidth = 0.1, fill = &quot;blue&quot;, col = &quot;black&quot;) p2 &lt;- p + geom_histogram(binwidth = 0.2, fill = &quot;red&quot;, col = &quot;black&quot;) p3 &lt;- p + geom_histogram(binwidth = 0.3, fill = &quot;green&quot;, col = &quot;black&quot;) Então usamos o pacote gridExtra para compor a imagem. Nesse exemplo, vamos dispor as imagens em uma linha e três colunas: library(gridExtra) grid.arrange(p1, p2, p3, ncol = 3) 4.2.8 Ajustes de Posição position = “identity” irá colocar cada objeto na posição exata em que ele cairia no contexto do gráfico p + geom_bar(aes(class, fill=Genotype), position=&quot;identity&quot;) position = “dodge” coloca objetos sobrepostos um ao lado do outro. Isto torna mais fácil a comparação de valores individuais p + geom_bar(aes(Genotype, fill=class), position=&quot;dodge&quot;) position = “fill” irá empilhar os elementos um sobre o outro, mas normalizando a altura. Isso é muito útil para comparar proporções entre os grupos p + geom_bar(aes(Genotype, fill=class), position=&quot;fill&quot;) 4.2.9 Geom Smooth ggplot(dados2, aes(SNCA_N,EGR1_N)) + geom_point() + geom_smooth(method = lm, size = 1) Para saber mais: Wickham, Çetinkaya-Rundel, and Grolemund (2023) Irizarry (2019)] 4.3 Outros pacotes gráficos Vamos carregar os dados e ativar os pacotes: library(ggplot2) library(RColorBrewer) library(openxlsx) library(dplyr) dados&lt;-read.xlsx(&quot;dados/pinguim.xlsx&quot;, sheet = 1, colNames = T) head(dados) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex year ## 1 male 2007 ## 2 female 2007 ## 3 female 2007 ## 4 &lt;NA&gt; 2007 ## 5 female 2007 ## 6 male 2007 4.3.1 Usando as cores Primeiro vamos fazer um gráfico, sem especificar quais cores usar: p &lt;- dados %&gt;% ggplot(aes(y = bill_length_mm, group=species, color=species)) p + geom_boxplot() No ggplot2, é possível armazenar a paleta de cores em uma variável e usá-la posteriormente. Por exemplo: cbPalette &lt;- c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;, &quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) Então podemos usar essas cores no gráfico: p &lt;- dados %&gt;% ggplot(aes(y = bill_length_mm, group=species, fill=species)) p + geom_boxplot()+ scale_fill_manual(values=cbPalette) Para o preenchimento adicionamos: scale_fill_manual(values=cbPalette) Para cor da linha ou pontos adicionamos: scale_colour_manual(values=cbPalette) Também podemos usar outras escalas de cores, como as retiradas do pacote RColorBrewer p + geom_boxplot()+ scale_fill_brewer(palette=&quot;Set1&quot;) p + geom_boxplot()+ scale_fill_brewer(palette=&quot;Oranges&quot;) Podem consultar as opções em: https://r-graph-gallery.com/38-rcolorbrewers-palettes.html 4.3.2 Análise gráfica exploratória library(GGally) dados2&lt;-select(dados, species, bill_length_mm:body_mass_g) Para isso usaremos o pacote GGally, que é uma extensão para o ggplot2. Vamos usar a função ggpairs e selecionar uma variável categórica para color: ggpairs(dados2, aes(color = species)) 4.3.3 GGPLOT2: mais parâmetros Vamos usar outro geom, o geom_segment: ggplot(dados, aes(x=bill_length_mm , y=bill_depth_mm )) + geom_segment( aes(x=bill_length_mm , xend=bill_length_mm , y=10, yend=bill_depth_mm), color=&quot;grey&quot;) + geom_point(color=&quot;orange&quot;, size=4) + theme_light() + theme( panel.grid.major.x = element_blank(), panel.border = element_blank(), axis.ticks.x = element_blank() ) + xlab(&quot;&quot;) + ylab(&quot;Value of Y&quot;) 4.3.4 Diagrama de Venn Vamos criar uma lista com dados aleatórios set.seed(654925) list_venn &lt;- list(A = sort(sample(1:100, 20)), B = sort(sample(1:100, 20)), C = sort(sample(1:100, 20)), D = sort(sample(1:100, 20))) head(list_venn) ## $A ## [1] 1 3 4 11 19 20 22 32 34 36 47 48 58 59 60 64 69 72 97 98 ## ## $B ## [1] 4 17 18 23 32 33 34 41 45 52 53 56 58 59 66 67 74 78 91 92 ## ## $C ## [1] 3 10 28 31 34 38 46 47 51 57 58 65 67 70 72 74 80 89 94 97 ## ## $D ## [1] 8 11 14 15 17 18 19 33 34 47 51 59 66 68 73 77 78 82 86 87 Carregar o pacote ggvenn e fazer o diagrama com A e C: library(ggvenn) ggvenn(list_venn, c(&quot;A&quot;, &quot;C&quot;)) Fazer o diagrama com A, C e D: ggvenn(list_venn, c(&quot;A&quot;, &quot;C&quot;, &quot;D&quot;)) Com todos os dados: ggvenn(list_venn) 4.3.5 Diagramas Muitas vezes precisamos fazer um diagrama, ou fluxograma, para mostrar as etapas da pesquisa e podemos fazer isso usando o pacote DiagrammeR library(DiagrammeR) figura1&lt;-DiagrammeR::grViz(&quot; digraph a_nice_graph { node [fontname = Helvetica, color = green] a [label = &#39;Ratos&#39;, color =blue, fontname=Impact] b [label = &#39;caso, n = 20&#39;] c [label = &#39;controle, n = 20&#39;] d [label = &#39;medicamento&#39;] e [label = &#39;salina&#39;] f [label = &#39;30 days&#39;] g [label = &#39;córtex&#39;, color= blue] h [label = &#39;hipocampo&#39; , color= blue] i [label = &#39;fígado&#39;, color =blue] j [label = &#39;atividade enzimática&#39;, color =red,fontname=Impact] # edge definitions with the node IDs a -&gt; {b c} b -&gt; d c -&gt; e {d e} -&gt; f f -&gt; {g h i} {g h i} -&gt; j } &quot;) figura1 Para salvar esse diagrama é preciso carregar mais 2 pacotes: rsvg e DiagrammeRsvg library(rsvg) library(DiagrammeRsvg) figura1 = DiagrammeRsvg::export_svg(figura1) figura1 = charToRaw(figura1) # flatten rsvg_png(figura1, file = &quot;figura1b.png&quot;, width = 5961, height = 7016) 4.3.6 Outra opção é o pacote ggflowchart Para usar esse pacote tem um tutorial no endereço abaixo: (https://nrennie.rbind.io/blog/introducing-ggflowchart/) library(ggflowchart) data &lt;- tibble::tibble(from = c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;F&quot;), to = c(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;)) ggflowchart(data) Podemos usar os seguintes parâmetros: fill = “white”. A cor de preenchimento. colour = “black”. A cor da caixa de texto. text_colour = “black”. A cor do texto. text_size = 3.88. O tamanho do texto. arrow_colour = “black”. A cor das flechas. arrow_size = 0.3. O tamanho das flechas. family = “sans”. A fonte do texto. x_nudge = 0.35. A largura da caixa de texto. y_nudge = 0.25. A altura da caica de texto. horizontal = FALSE. A direção do fluxograma. Alguns exemplos: ggflowchart(data, colour = &quot;blue&quot;, text_colour = &quot;red&quot;, arrow_colour = &quot;green&quot;, family = &quot;serif&quot;, x_nudge = 0.4, y_nudge = 0.2, arrow_size = 0.3) Com fluxograma na horizontal: ggflowchart(data, colour = &quot;blue&quot;, text_colour = &quot;black&quot;, arrow_colour = &quot;orange&quot;, family = &quot;serif&quot;, x_nudge = 0.4, y_nudge = 0.2, arrow_size = 0.3, horizontal = T) Utilizando tipos diferentes: node_data &lt;- tibble::tibble( name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;), type = c(&quot;Type 1&quot;, &quot;Type 1&quot;, &quot;Type 1&quot;, &quot;Type 1&quot;, &quot;Type 2&quot;, &quot;Type 2&quot;, &quot;Type 2&quot;) ) ggflowchart(data, node_data, fill = type) 4.3.7 Datas e séries temporais Vamos plotar uma variável (peso) ao longo do tempo. Primeiro vamos carregar os dados: dados3&lt;-read.xlsx(&quot;dados/peso.xlsx&quot;, sheet=1,colNames = T) head(dados3) ## ID grupo tempo peso ## 1 1 controle t1 270 ## 2 2 controle t1 287 ## 3 3 controle t1 279 ## 4 4 controle t1 286 ## 5 5 controle t1 275 ## 6 6 controle t1 282 Nesse arquivo temos a variável grupo (caso e controle), uma variável tempo (t1 a t6) e a variável peso. São 2 grupos de animais, que foram pesados em 6 momentos. Agora ativaremos uma função para organizar os dados para poder fazer o gráfico: data_summary &lt;- function(data, varname, groupnames){ require(plyr) summary_func &lt;- function(x, col){ c(mean = mean(x[[col]], na.rm=TRUE), sd = sd(x[[col]], na.rm=TRUE)) } data_sum&lt;-ddply(data, groupnames, .fun=summary_func, varname) data_sum &lt;- rename(data_sum, c(&quot;mean&quot; = varname)) return(data_sum) } Agora que a função data_summary está ativa, vamos preparar os dados: df &lt;- data_summary(dados3, varname=&quot;peso&quot;, groupnames=c(&quot;grupo&quot;, &quot;tempo&quot;)) df ## grupo tempo peso sd ## 1 caso t1 287.1429 32.28207 ## 2 caso t2 262.3571 13.78186 ## 3 caso t3 265.5000 27.38262 ## 4 caso t4 268.5714 26.69115 ## 5 caso t5 293.7143 28.22554 ## 6 caso t6 327.7857 36.65049 ## 7 controle t1 294.0000 32.87011 ## 8 controle t2 308.6000 37.88931 ## 9 controle t3 330.2000 21.04915 ## 10 controle t4 347.1000 20.14641 ## 11 controle t5 375.1000 21.74320 ## 12 controle t6 408.6000 17.94560 E finalmente o gráfico: p&lt;- ggplot(df, aes(x=tempo, y=peso, group=grupo, color=grupo)) + geom_line() + geom_point() + geom_errorbar(aes(ymin=peso-sd, ymax=peso+sd), width=.2, position=position_dodge(0.05)) p Personalizando o gráfico: p+labs(title=&quot;Weight variation along 30 days&quot;, x=&quot;Time&quot;, y = &quot;Weight&quot;)+ theme_classic() + scale_color_manual(values=c(&#39;#999999&#39;,&#39;#E69F00&#39;)) Além da definição das cores, que já vimos, aqui usamos também o theme_classic() Esses temas controlam outros aspectos visuais do gráfico. Tem vários temas: theme_grey() theme_gray() theme_bw() theme_linedraw() theme_light() theme_dark() theme_minimal() theme_classic() theme_void() theme_test() 4.3.8 Time series - Dados de casos de COVID no Paraná Os dados podem ser baixados de: https://www.saude.pr.gov.br/Pagina/Coronavirus-COVID-19 Como exemplo, vou usar os dados de março de 2022, porque quanto mais recente, maior o arquivo e demora mais para carregar e processar os dados. Carregar os dados: dados&lt;-read.csv(&quot;dados/informe_epidemiologico_16_03_2022_geral.csv&quot;, header = T, sep = &quot;;&quot;) library(dplyr) head(dados) ## IBGE_RES_PR IBGE_ATEND_PR UF_RESIDENCIA SEXO IDADE_ORIGINAL ## 1 4118501 4118501 PR M 96 ## 2 4106902 4106902 PR F 77 ## 3 4125704 4108304 PR M 73 ## 4 4106902 4106902 PR F 95 ## 5 4119905 4119905 PR M 81 ## 6 4116802 4116802 PR M 56 ## MUN_RESIDENCIA MUN_ATENDIMENTO EXAME DATA_DIAGNOSTICO ## 1 PATO BRANCO PATO BRANCO 167 2022-03-02 ## 2 CURITIBA CURITIBA 167 2022-02-22 ## 3 SAO MIGUEL DO IGUACU FOZ DO IGUACU 27 2022-02-21 ## 4 CURITIBA CURITIBA 27 2022-01-20 ## 5 PONTA GROSSA PONTA GROSSA 27 2022-01-31 ## 6 NOVA CANTU NOVA CANTU 1 2022-03-07 ## DATA_CONFIRMACAO_DIVULGACAO DATA_INICIO_SINTOMAS ÓBITO.COVID.19 DATA_OBITO ## 1 2022-03-16 2022-02-24 SIM 2022-02-28 ## 2 2022-03-16 SIM 2022-03-14 ## 3 2022-03-16 2022-02-21 SIM 2022-03-07 ## 4 2022-03-16 2022-01-14 SIM 2022-02-06 ## 5 2022-03-16 2022-01-21 SIM 2022-03-04 ## 6 2022-03-16 2022-03-01 SIM 2022-03-14 ## DATA_OBITO_DIVULGACAO STATUS DATA_RECUPERADO_DIVULGACAO ## 1 2022-03-16 Óbito por COVID-19 ## 2 2022-03-16 Óbito por COVID-19 ## 3 2022-03-16 Óbito por COVID-19 ## 4 2022-03-16 Óbito por COVID-19 ## 5 2022-03-16 Óbito por COVID-19 ## 6 2022-03-16 Óbito por COVID-19 ## ORIGEM_NOTIFICACAO ## 1 Vigilância Epidemiológica de Pato Branco ## 2 e-Saúde ## 3 Notifica COVID-19 ## 4 e-Saúde ## 5 Notifica COVID-19 ## 6 Notifica COVID-19 dados&lt;-select(dados, SEXO:MUN_RESIDENCIA,DATA_DIAGNOSTICO,DATA_INICIO_SINTOMAS,DATA_OBITO) Os dados tem colunas com data, no entanto, para o R entender que são datas devemos usar o pacote lubridate. Devemos olhar como está o formato da data. Nesse caso estão no formato ano, mês, dia, então usamos função ymd: library(lubridate) dados$DATA_INICIO_SINTOMAS &lt;-ymd(dados$DATA_INICIO_SINTOMAS) dados$DATA_DIAGNOSTICO &lt;-ymd(dados$DATA_DIAGNOSTICO) dados$DATA_OBITO &lt;-ymd(dados$DATA_OBITO) Podemos plotar o número de casos por data de diagnóstico: library(ggplot2) p &lt;- dados %&gt;% ggplot(aes(DATA_DIAGNOSTICO)) p + geom_bar(fill = &quot;dodgerblue&quot;) Podemos ver a idade dos casos positivos: dados %&gt;% filter(IDADE_ORIGINAL&gt;=0)%&gt;% ggplot(mapping = aes(IDADE_ORIGINAL )) + geom_bar(fill=&quot;goldenrod1&quot;, col=&quot;black&quot;) Ou a idade dos casos de óbito: dados %&gt;% filter(!is.na(DATA_OBITO))%&gt;% ggplot(mapping = aes(x =IDADE_ORIGINAL )) + geom_bar(fill=&quot;firebrick1&quot;, col=&quot;black&quot;) Podemos separa por sexo: dados %&gt;% ggplot(aes(DATA_DIAGNOSTICO, color = SEXO, fill=SEXO)) + geom_density(alpha=0.2 ) Filtros Podemos usar filtros, por exemplo, por data: p &lt;- dados %&gt;% filter(DATA_DIAGNOSTICO&gt;as.Date(&quot;2022-02-15&quot;))%&gt;% ggplot(aes(DATA_DIAGNOSTICO)) p + geom_bar(fill = &quot;dodgerblue&quot;) Filtrando por município: p &lt;- dados %&gt;% filter(MUN_RESIDENCIA==&quot;PONTA GROSSA&quot;)%&gt;% ggplot(aes(x = DATA_DIAGNOSTICO)) p + geom_bar(fill = &quot;blue&quot;) Além desses gráficos todos apresentados aqui, existem muitos outros, os quais vocês podem procurar conforme a necessidade. Mais detalhes podem ser obtidos em Wickham, Çetinkaya-Rundel, and Grolemund (2023) References "],["estatística.html", "Capítulo 5 Estatística 5.1 Estatística descritiva 5.2 Testes estatísticos 5.3 Visualização de resultados estatísticos", " Capítulo 5 Estatística 5.1 Estatística descritiva O R permite fazer qualquer teste estatístico. No R base já temos o pacote stats que possibilita fazer vários testes estatísticos. Além disso temos muitos outros pacotes estatísticos. Primeiro vamos fazer uma estatística descritiva, obtendo os valores de média, mediana, desvio padrão, máximo, mínimo. Os dados que vamos usar estão no pacote palmerpenguins. library(openxlsx) dados&lt;-read.xlsx(&quot;dados/pinguim.xlsx&quot;, sheet = 1, colNames = T) head(dados) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex year ## 1 male 2007 ## 2 female 2007 ## 3 female 2007 ## 4 &lt;NA&gt; 2007 ## 5 female 2007 ## 6 male 2007 # caracterização mean(dados$bill_length_mm , na.rm=T) # média ## [1] 43.92193 median(dados$bill_length_mm , na.rm=T) # mediana ## [1] 44.45 sd(dados$bill_length_mm , na.rm=T) # desvio padrão ## [1] 5.459584 max(dados$bill_length_mm , na.rm=T) # máximo ## [1] 59.6 min(dados$bill_length_mm , na.rm=T) # mínimo ## [1] 32.1 summary(dados$bill_length_mm ) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 32.10 39.23 44.45 43.92 48.50 59.60 2 5.2 Testes estatísticos Tipos de testes estatísticos Existem testes paramétricos e não paramétricos. Primeiro passo: verificar como é a distribuição dos nossos dados. Podemos fazer um gráfico assim: m&lt;-mean(dados$bill_length_mm ,na.rm=TRUE) std&lt;-sd(dados$bill_length_mm ,na.rm=TRUE) hist(dados$bill_length_mm , prob=TRUE) curve(dnorm(x, mean=m, sd=std), col=&quot;darkblue&quot;, lwd=2, add=TRUE, yaxt=&quot;n&quot;) Ou podemos fazer um gráfico qq plot: library(ggplot2) library(dplyr) p &lt;- dados %&gt;% ggplot(aes(sample= bill_length_mm)) params &lt;- dados %&gt;% summarize(mean = mean(bill_length_mm, na.rm = T), sd = sd(bill_length_mm, na.rm=T)) p + geom_qq(dparams = params)+ geom_abline() 5.2.1 Normalidade Através dos gráficos podemos ter uma ideia da distribuição dos dados, mas isso não é um teste estatístico. Para testar a normalidade podemos usar o teste Kolmogorov-Smirnov com correção de Lilliefors, para isso precisamos instalar ativar o pacote nortest: library(nortest) lillie.test(dados$bill_length_mm ) ## ## Lilliefors (Kolmogorov-Smirnov) normality test ## ## data: dados$bill_length_mm ## D = 0.069803, p-value = 0.0003883 Esses dados são de diferentes espécies, então devemos testar a normalidade em cada grupo: library(dplyr) adelie&lt;-filter(dados, species==&quot;Adelie&quot;) gentoo&lt;-filter(dados, species==&quot;Gentoo&quot;) chinstrap&lt;-filter(dados, species==&quot;Chinstrap&quot;) lillie.test(adelie$bill_length_mm) ## ## Lilliefors (Kolmogorov-Smirnov) normality test ## ## data: adelie$bill_length_mm ## D = 0.042489, p-value = 0.7254 lillie.test(gentoo$bill_length_mm) ## ## Lilliefors (Kolmogorov-Smirnov) normality test ## ## data: gentoo$bill_length_mm ## D = 0.062001, p-value = 0.2929 lillie.test(chinstrap$bill_length_mm) ## ## Lilliefors (Kolmogorov-Smirnov) normality test ## ## data: chinstrap$bill_length_mm ## D = 0.093769, p-value = 0.1459 Também podemos usar o teste de Shapiro-Wilk para testar a normalidade: shapiro.test(adelie$bill_length_mm) ## ## Shapiro-Wilk normality test ## ## data: adelie$bill_length_mm ## W = 0.99336, p-value = 0.7166 shapiro.test(gentoo$bill_length_mm) ## ## Shapiro-Wilk normality test ## ## data: gentoo$bill_length_mm ## W = 0.97272, p-value = 0.01349 shapiro.test(chinstrap$bill_length_mm) ## ## Shapiro-Wilk normality test ## ## data: chinstrap$bill_length_mm ## W = 0.97525, p-value = 0.1941 5.2.2 Assimetria e curtose Em estatística, assimetria (skewness) e curtose (kurtosis) são duas maneiras de medir a forma de uma distribuição. A assimetria é uma medida da assimetria de uma distribuição. Este valor pode ser positivo ou negativo. Um valor de zero indica que não há assimetria na distribuição, o que significa que a distribuição é perfeitamente simétrica. Curtose mede a concentração ou dispersão dos valores de um conjunto de valores em relação às medidas de tendência central. A curtose de uma distribuição normal é 3. Se uma dada distribuição tem uma curtose menor que 3, ela tende a produzir menos outliers e menos extremos do que a distribuição normal. Se uma dada distribuição tem uma curtose maior que 3, ela tende a produzir mais outliers do que a distribuição normal. library(moments) skewness(adelie$bill_length_mm, na.rm = T) ## [1] 0.1600638 # zero não tem skewnwss # para valor de p: agostino.test(adelie$bill_length_mm) ## ## D&#39;Agostino skewness test ## ## data: adelie$bill_length_mm ## skew = 0.16006, z = 0.83425, p-value = 0.4041 ## alternative hypothesis: data have a skewness # para kurtosis, o valor sem kurtosis é 3 kurtosis(adelie$bill_length_mm, na.rm = T) ## [1] 2.80848 # para valor de p: anscombe.test(adelie$bill_length_mm) ## ## Anscombe-Glynn kurtosis test ## ## data: adelie$bill_length_mm ## kurt = 2.80848, z = -0.28403, p-value = 0.7764 ## alternative hypothesis: kurtosis is not equal to 3 Se os dados tem distribuição normal podemos comparar as médias usando o teste t, mas precisamos saber se as variâncias são iguais: var.test(adelie$bill_length_mm, gentoo$bill_length_mm) ## ## F test to compare two variances ## ## data: adelie$bill_length_mm and gentoo$bill_length_mm ## F = 0.74688, num df = 150, denom df = 122, p-value = 0.08894 ## alternative hypothesis: true ratio of variances is not equal to 1 ## 95 percent confidence interval: ## 0.5303445 1.0455238 ## sample estimates: ## ratio of variances ## 0.7468774 5.2.3 Teste t t.test(adelie$bill_length_mm, gentoo$bill_length_mm, var.equal=T) ## ## Two Sample t-test ## ## data: adelie$bill_length_mm and gentoo$bill_length_mm ## t = -25.095, df = 272, p-value &lt; 2.2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -9.397060 -8.029915 ## sample estimates: ## mean of x mean of y ## 38.79139 47.50488 Se o teste de variância não foi significativo, usamos var.equal=T, caso contrário, usamos var.equal=F Para dados não paramétricos temos o teste Mann-Whitney (para duas amostras) ou Wilcoxon (para uma amostra pareada: paired = T): wilcox.test(adelie$bill_length_mm, gentoo$bill_length_mm) ## ## Wilcoxon rank sum test with continuity correction ## ## data: adelie$bill_length_mm and gentoo$bill_length_mm ## W = 224.5, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 5.2.4 Teste qui-quadrado chisq.test(x, correct = TRUE, simulate.p.value = FALSE, B = 2000) correct: one half is subtracted from all |O - E| differences simulate.p.value: a logical indicating whether to compute p-values by Monte Carlo simulation B: an integer specifying the number of replicates used in the Monte Carlo test Exemplos: x&lt;-rbind(c(163,147),c(109,125)) # criar tabela com os dados x ## [,1] [,2] ## [1,] 163 147 ## [2,] 109 125 chisq.test(x,correct=F) ## ## Pearson&#39;s Chi-squared test ## ## data: x ## X-squared = 1.9198, df = 1, p-value = 0.1659 x&lt;-rbind(c(163,147,130),c(109,125,125)) x ## [,1] [,2] [,3] ## [1,] 163 147 130 ## [2,] 109 125 125 chisq.test(x,correct=F) ## ## Pearson&#39;s Chi-squared test ## ## data: x ## X-squared = 4.4321, df = 2, p-value = 0.109 chisq.test(x,simulate.p.value = T, B = 10000) ## ## Pearson&#39;s Chi-squared test with simulated p-value (based on 10000 ## replicates) ## ## data: x ## X-squared = 4.4321, df = NA, p-value = 0.104 5.2.5 Correlação cor(x, use=, method= ) use: como tratar dados faltantes. Options are all.obs (sem NA), complete.obs (listwise deletion), pairwise.complete.obs (pairwise deletion) method tipo de correlação. Options are pearson, spearman or kendall. Pearson (entre duas variáveis contínuas), que é um teste paramétrico. Spearman (ou rho) ? uma correlação de “rankings” ou “postos”, # e por isso é um teste não-paramétrico Kendall (ou tau) vai na mesma linha não-paramétrica da correlação de Spearman cor(adelie$bill_length_mm , adelie$body_mass_g, use=&quot;pairwise.complete.obs&quot;, method = &quot;pearson&quot;) ## [1] 0.5488658 # plot the data library(PerformanceAnalytics) mydata&lt;-select(adelie, bill_length_mm :body_mass_g) chart.Correlation(mydata, method = &quot;pearson&quot;) 5.2.6 Regressão A regressão linear é uma análise que avalia se uma ou mais variáveis preditoras explicam a variável dependente. A regressão tem cinco pressupostos principais: Relação linear Normalidade Nenhuma ou pouca multicolinearidade Sem auto-correlação Homocedasticidade (Homogeneidade de Variância) Na regressão linear requer pelo menos 20 casos por variável independente na análise. Vamos transformar as variáveis species e island em uma variável numérica, utilizando mutate e ifelse: dados&lt;-mutate(dados, especie= ifelse(grepl(&quot;Adelie&quot;,species), 0, ifelse(grepl(&quot;Gentoo&quot;, species),1,2))) dados&lt;-mutate(dados, ilha= ifelse(grepl(&quot;Torgersen&quot;,island), 0, ifelse(grepl(&quot;Biscoe&quot;, island),1,2))) head(dados) ## species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 1 Adelie Torgersen 39.1 18.7 181 3750 ## 2 Adelie Torgersen 39.5 17.4 186 3800 ## 3 Adelie Torgersen 40.3 18.0 195 3250 ## 4 Adelie Torgersen NA NA NA NA ## 5 Adelie Torgersen 36.7 19.3 193 3450 ## 6 Adelie Torgersen 39.3 20.6 190 3650 ## sex year especie ilha ## 1 male 2007 0 0 ## 2 female 2007 0 0 ## 3 female 2007 0 0 ## 4 &lt;NA&gt; 2007 0 0 ## 5 female 2007 0 0 ## 6 male 2007 0 0 O grepl é uma função que procura correspondências de uma string ou vetor de string. O método grepl() pega um padrão e retorna TRUE se uma string contiver o padrão, caso contrário, FALSE. No R temos duas funções para fazer a regressão: lm, Usada para ajustar modelos lineares lm(formula, data, …) fórmula: (y ~ x1 + x2) glm, Usada para ajustar modelos lineares generalizados. glm(formula, family=gaussian, data, …) family: A família estatística a ser usada para ajustar o modelo. O padrão é gaussiano, mas outras opções incluem binomial, gama e poisson, entre outros. Fazendo a regressão com a função glm, como variável dependente body_mass_g e como variáveis independentes especie e ilha: regressao&lt;-glm(body_mass_g ~ especie + ilha, data=dados, family=gaussian) summary(regressao) ## ## Call: ## glm(formula = body_mass_g ~ especie + ilha, family = gaussian, ## data = dados) ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4415.04 82.42 53.568 &lt; 2e-16 *** ## especie 390.51 59.15 6.602 1.57e-10 *** ## ilha -419.48 66.06 -6.350 6.92e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for gaussian family taken to be 552729.2) ## ## Null deviance: 219307697 on 341 degrees of freedom ## Residual deviance: 187375185 on 339 degrees of freedom ## (2 observations deleted due to missingness) ## AIC: 5497.7 ## ## Number of Fisher Scoring iterations: 2 5.2.7 ANOVA Análise de variância (ANOVA) A análise da variância (ou ANOVA, de “ANalysis Of VAriance”) é uma poderosa técnica estatística desenvolvida por R.A. Fisher. Ela consiste em um procedimento que decompõe, em vários componentes identificáveis, a variação total entre os valores obtidos no experimento. Cada componente atribui a variação a uma causa ou fonte de variação diferente: o número de causas de variação ou “fatores” depende do delineamento da investigação. Um dos modelos mais simples de ANOVA é o que analisa os dados de um delineamento completamente casualizado ou ANOVA a um critério de classificação (One way ANOVA). Neste modelo, a variação global é subdividida em duas frações. A primeira é a variação entre as médias dos vários grupos, quando comparadas com a média geral de todos os indivíduos do experimento e representa o efeito dos diferentes tratamentos. A outra é a variação observada entre as unidades experimentais de um mesmo grupo ou tratamento, com relação à média desse grupo: tratam-se das diferenças individuais, ou aleatórias, nas respostas. Resumidamente: Variação total = Variação entre tratamentos + Variação dentro dos tratamentos. A variação entre grupos experimentais ou tratamentos é estimada pela variância entre tratamentos ou simplesmente Variância Entre. A variação dentro do mesmo tratamento é estimada pela média das variâncias de cada grupo: é por isso chamada variancia média dentro dos grupos ou Variância Dentro. Como ela representa também a fração da variabilidade que não é explicada pelo efeito dos tratamentos, é também chamada Variância Residual ou, ainda, Variância do Erro Experimental. O teste de comparação entre os efeitos dos tratamentos baseia-se na pressuposição de que os k tratamentos A,B,… podem originar médias diferentes, mas a entre os indivíduos (o) é igual em todas as populações que estão sendo comparadas. Em outras palavras, deseja-se testar a hipótese de igualdade estre médias. Antes de fazer a ANOVA, vamos fazer o teste de Bartlett para verificar a variância: library(car) bartlett.test(bill_length_mm ~species,data=dados) ## ## Bartlett test of homogeneity of variances ## ## data: bill_length_mm by species ## Bartlett&#39;s K-squared = 5.6179, df = 2, p-value = 0.06027 Como não foi significativo, vamos fazer a ANOVA com a função aov: res_anova&lt;-aov(bill_length_mm~species,data=dados) summary(res_anova) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## species 2 7194 3597 410.6 &lt;2e-16 *** ## Residuals 339 2970 9 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## 2 observations deleted due to missingness O resultado foi significativo, mas com a ANOVA sabemos que tem diferença, mas não sabemos entre quais grupos,então podemos usar o teste de Duncan: library(agricolae) duncan.test(res_anova,&quot;species&quot;,console = T) ## ## Study: res_anova ~ &quot;species&quot; ## ## Duncan&#39;s new multiple range test ## for bill_length_mm ## ## Mean Square Error: 8.760732 ## ## species, means ## ## bill_length_mm std r Min Max ## Adelie 38.79139 2.663405 151 32.1 46.0 ## Chinstrap 48.83382 3.339256 68 40.9 58.0 ## Gentoo 47.50488 3.081857 123 40.9 59.6 ## ## Groups according to probability of means differences and alpha level( 0.05 ) ## ## Means with the same letter are not significantly different. ## ## bill_length_mm groups ## Chinstrap 48.83382 a ## Gentoo 47.50488 b ## Adelie 38.79139 c Para vizualizar essas diferenças podemos fazer gráficos: library(&quot;ggpubr&quot;) ggline(dados, x = &quot;species&quot;, y = &quot;bill_length_mm&quot;, add = c(&quot;mean_se&quot;, &quot;jitter&quot;), ylab = &quot;bill_length_mm&quot;, xlab = &quot;espécies&quot;,color = &quot;species&quot;) ggboxplot(dados, x = &quot;species&quot;, y = &quot;bill_length_mm&quot;, color = &quot;species&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;, &quot;#FC4E07&quot;), ylab = &quot;bill_length_mm&quot;, xlab = &quot;species&quot;) Para dados não paramétricos, podemos usar o teste de Kruskal-Wallis kruskal.test(bill_length_mm ~ species, data = dados) ## ## Kruskal-Wallis rank sum test ## ## data: bill_length_mm by species ## Kruskal-Wallis chi-squared = 244.14, df = 2, p-value &lt; 2.2e-16 Para esse caso, podemos o usar o teste de Dunn para identificar as diferenças: library(FSA) dunnTest(bill_length_mm ~ species, data = dados, method=&quot;bh&quot;) ## Comparison Z P.unadj P.adj ## 1 Adelie - Chinstrap -12.753511 2.980163e-37 4.470244e-37 ## 2 Adelie - Gentoo -13.135630 2.057716e-39 6.173147e-39 ## 3 Chinstrap - Gentoo 1.767498 7.714481e-02 7.714481e-02 5.3 Visualização de resultados estatísticos Vamos usar alguns pacotes que vão ajudar na análise de dados e também gerar um relatório com tabelas e gráficos em um documento html ou doc. O pacote DataExplorer permite fazer diversas análises. Podemos ter uma visão inicial dos dados com a função introduce library(DataExplorer) introduce(dados) ## rows columns discrete_columns continuous_columns all_missing_columns ## 1 344 10 3 7 0 ## total_missing_values complete_rows total_observations memory_usage ## 1 19 333 3440 31032 Também podemos ver na forma de gráficos: plot_intro(dados) Os dados categóricos podem ser plotados: plot_bar(dados, by=&quot;species&quot;) dados%&gt;% select(species, bill_length_mm:body_mass_g)%&gt;% plot_boxplot(by=&quot;species&quot;) Outro pacote muito útil é o ggstatsplot, com o qual podemos unir gráficos e análises estatísticas. Por exemplo, para dados categóricos: library(ggstatsplot) ## You can cite this package as: ## Patil, I. (2021). Visualizations with statistical details: The &#39;ggstatsplot&#39; approach. ## Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167 ggbarstats(data = dados, x = species , y= island, label = &quot;both&quot;) Ou para dados numéricos: ggbetweenstats(data= dados, x=species, y=bill_length_mm, type = &quot;p&quot;) Onde em type temos as seguintes opções: p (parametric), np (non parametric), r (robust), bf (bayes). O pacote dlookr descreve cada variável e o pacote flextable permite criar tabelas com os resultados. Podemos fazer diversas análises usando a função describe. library(dlookr) library(flextable) dlookr::describe(dados)%&gt;% flextable() .cl-81ca3056{}.cl-81b9f8a8{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-81c039e8{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-81c039f2{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-81c05e78{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-81c05e82{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-81c05e8c{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-81c05e8d{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-81c05e96{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-81c05e97{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}described_variablesnnameansdse_meanIQRskewnesskurtosisp00p01p05p10p20p25p30p40p50p60p70p75p80p90p95p99p100bill_length_mm342243.9219305.45958370.295220489.2750.05311807-0.876027032.134.04135.736.638.3439.22540.2042.044.4546.047.3748.549.3850.851.99555.51359.6bill_depth_mm342217.1511701.97479320.106784583.100-0.14346463-0.906866113.113.44113.914.315.0015.60015.9316.817.3017.918.5018.718.9019.520.00021.10021.5flipper_length_mm3422200.91520514.06171370.7603703923.0000.34568183-0.9842729172.0178.000181.0185.0188.00190.000191.00194.0197.00203.0210.00213.0215.00220.9225.000230.000231.0body_mass_g34224,201.754386801.954535743.364734821,200.0000.47032933-0.71922192,700.02,900.0003,150.03,300.03,475.003,550.0003,650.003,800.04,050.004,300.04,650.004,750.04,950.005,400.05,650.0005,979.5006,300.0year34402,008.0290700.81835590.044122792.000-0.05372777-1.50493662,007.02,007.0002,007.02,007.02,007.002,007.0002,007.002,008.02,008.002,008.02,009.002,009.02,009.002,009.02,009.0002,009.0002,009.0especie34400.7558140.76262620.041118051.0000.44393545-1.15823830.00.0000.00.00.000.0000.000.01.001.01.001.01.002.02.0002.0002.0ilha34401.2093020.68497030.036931131.000-0.29384888-0.86997120.00.0000.00.01.001.0001.001.01.001.02.002.02.002.02.0002.0002.0 # obs, usar dlookr:: porque describe tem em outros 2 pacotes Também podemos usar a função diagnose_numeric: dados%&gt;% diagnose_numeric()%&gt;% flextable() .cl-8214fc26{}.cl-8205ea92{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-820b02a2{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-820b02b6{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-820b2548{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-820b2552{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-820b255c{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-820b2566{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-820b2567{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-820b2570{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}variablesminQ1meanmedianQ3maxzerominusoutlierbill_length_mm32.139.22543.92193044.4548.559.6000bill_depth_mm13.115.60017.15117017.3018.721.5000flipper_length_mm172.0190.000200.915205197.00213.0231.0000body_mass_g2,700.03,550.0004,201.7543864,050.004,750.06,300.0000year2,007.02,007.0002,008.0290702,008.002,009.02,009.0000especie0.00.0000.7558141.001.02.015200ilha0.01.0001.2093021.002.02.05200 O pacote SmartEDA também faz um resumo descritivo das variáveis numéricas library(SmartEDA) ExpNumStat(dados, by=&quot;A&quot;, round = 2)%&gt;% flextable() .cl-825172be{}.cl-824457f0{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-82496d08{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82496d1c{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-824987d4{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-824987de{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-824987e8{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-824987f2{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-824987f3{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-824987fc{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}VnameGroupTNnNegnZeronPosNegInfPosInfNA_ValuePer_of_MissingsumminmaxmeanmedianSDCVIQRSkewnessKurtosisbill_depth_mmAll344003420020.585,865.713.121.517.1517.301.970.123.10-0.14-0.91bill_length_mmAll344003420020.5815,021.332.159.643.9244.455.460.129.270.05-0.88body_mass_gAll344003420020.581,437,000.02,700.06,300.04,201.754,050.00801.950.191,200.000.47-0.73flipper_length_mmAll344003420020.5868,713.0172.0231.0200.92197.0014.060.0723.000.34-0.99 Em by temos as opções A: All, G: by group e GA: by group e Overall: ExpNumStat(dados, by=&quot;G&quot;, gp=&quot;species&quot;, round = 2)%&gt;% flextable() .cl-82916cfc{}.cl-8282d264{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-8288389e{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-828838b2{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82885676{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82885677{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82885680{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82885681{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8288568a{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-8288568b{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}VnameGroupTNnNegnZeronPosNegInfPosInfNA_ValuePer_of_MissingsumminmaxmeanmedianSDCVIQRSkewnessKurtosisbill_depth_mmspecies:Adelie152001510010.662,770.315.521.518.3518.401.220.071.500.32-0.10bill_depth_mmspecies:Gentoo124001230010.811,842.813.117.314.9815.000.980.071.500.32-0.61bill_depth_mmspecies:Chinstrap6800680000.001,252.616.420.818.4218.451.140.061.900.01-0.90bill_length_mmspecies:Adelie152001510010.665,857.532.146.038.7938.802.660.074.000.16-0.19bill_length_mmspecies:Gentoo124001230010.815,843.140.959.647.5047.303.080.064.250.641.20bill_length_mmspecies:Chinstrap6800680000.003,320.740.958.048.8349.553.340.074.73-0.09-0.05body_mass_gspecies:Adelie152001510010.66558,800.02,850.04,775.03,700.663,700.00458.570.12650.000.28-0.59body_mass_gspecies:Gentoo124001230010.81624,350.03,950.06,300.05,076.025,000.00504.120.10800.000.07-0.74body_mass_gspecies:Chinstrap6800680000.00253,850.02,700.04,800.03,733.093,700.00384.340.10462.500.240.46flipper_length_mmspecies:Adelie152001510010.6628,683.0172.0210.0189.95190.006.540.039.000.090.28flipper_length_mmspecies:Gentoo124001230010.8126,714.0203.0231.0217.19216.006.480.039.000.39-0.60flipper_length_mmspecies:Chinstrap6800680000.0013,316.0178.0212.0195.82196.007.130.0410.00-0.01-0.04 ExpNumStat(dados, by=&quot;GA&quot;, gp=&quot;species&quot;, round = 2)%&gt;% flextable() .cl-82d13f3a{}.cl-82c12e1a{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-82c6efe4{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82c6eff8{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82c70d94{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82c70d9e{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82c70da8{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82c70da9{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82c70db2{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82c70db3{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}VnameGroupTNnNegnZeronPosNegInfPosInfNA_ValuePer_of_MissingsumminmaxmeanmedianSDCVIQRSkewnessKurtosisbill_depth_mmspecies:All344003420020.585,865.713.121.517.1517.301.970.123.10-0.14-0.91bill_depth_mmspecies:Adelie152001510010.662,770.315.521.518.3518.401.220.071.500.32-0.10bill_depth_mmspecies:Gentoo124001230010.811,842.813.117.314.9815.000.980.071.500.32-0.61bill_depth_mmspecies:Chinstrap6800680000.001,252.616.420.818.4218.451.140.061.900.01-0.90bill_length_mmspecies:All344003420020.5815,021.332.159.643.9244.455.460.129.270.05-0.88bill_length_mmspecies:Adelie152001510010.665,857.532.146.038.7938.802.660.074.000.16-0.19bill_length_mmspecies:Gentoo124001230010.815,843.140.959.647.5047.303.080.064.250.641.20bill_length_mmspecies:Chinstrap6800680000.003,320.740.958.048.8349.553.340.074.73-0.09-0.05body_mass_gspecies:All344003420020.581,437,000.02,700.06,300.04,201.754,050.00801.950.191,200.000.47-0.73body_mass_gspecies:Adelie152001510010.66558,800.02,850.04,775.03,700.663,700.00458.570.12650.000.28-0.59body_mass_gspecies:Gentoo124001230010.81624,350.03,950.06,300.05,076.025,000.00504.120.10800.000.07-0.74body_mass_gspecies:Chinstrap6800680000.00253,850.02,700.04,800.03,733.093,700.00384.340.10462.500.240.46flipper_length_mmspecies:All344003420020.5868,713.0172.0231.0200.92197.0014.060.0723.000.34-0.99flipper_length_mmspecies:Adelie152001510010.6628,683.0172.0210.0189.95190.006.540.039.000.090.28flipper_length_mmspecies:Gentoo124001230010.8126,714.0203.0231.0217.19216.006.480.039.000.39-0.60flipper_length_mmspecies:Chinstrap6800680000.0013,316.0178.0212.0195.82196.007.130.0410.00-0.01-0.04 Podemos ter os dados de saída de diversas análises estatísticas organizados com o pacote report. library(report) dados2&lt;-na.omit(dados) flextable(report_table(wilcox.test(dados2$bill_length_mm~dados2$sex))) .cl-82fc30c8{}.cl-82edcf06{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-82f2b16a{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82f2b1b0{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-82f2d0c8{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82f2d0d2{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82f2d0dc{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-82f2d0e6{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}Parameter1Parameter2WpMethodAlternativer_rank_biserialrank_biserial_CI_lowrank_biserial_CI_highdados2$bill_length_mmdados2$sex8,1780.00000000009901184Wilcoxon rank sum testtwo.sided-0.4099567-0.5078078-0.301662 Também podemos personalizar as tabelas geradas pelo pacote flextable. flextable(report_table(wilcox.test(dados2$bill_length_mm~dados2$sex)))%&gt;% colformat_double(digits = 2)%&gt;% style(i = 1, j = 4, pr_t = fp_text_default(bold = T)) .cl-83230a04{}.cl-83168aa4{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-83168aae{font-family:'Arial';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-831b6c54{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-831b6c68{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-831b8554{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-831b855e{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-831b855f{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-831b8568{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}Parameter1Parameter2WpMethodAlternativer_rank_biserialrank_biserial_CI_lowrank_biserial_CI_highdados2$bill_length_mmdados2$sex8,178.000.00Wilcoxon rank sum testtwo.sided-0.41-0.51-0.30 Para saber mais consulte Irizarry (2019) e Gohel (2023) References "],["funções-e-loops.html", "Capítulo 6 Funções e loops 6.1 Funções 6.2 Loops 6.3 if e else 6.4 Funções apply, lapply, sapply, tapply, mapply", " Capítulo 6 Funções e loops 6.1 Funções Uma função recebe alguns dados de entrada, faz algumas operações e devolve os dados de saída. funcao&lt;-function(x, y) #criando uma função { #inicio result&lt;- x^2+y^2 #calculando return(result) #valor a ser retornado } #fim Usando a função: funcao(10,6) ## [1] 136 Quando ativamos um pacote, estamos ativando as funções daquele pacote. Podemos ver o conteúdo das funções digitando e executando o nome da função. funcao ## function(x, y) #criando uma função ## { #inicio ## result&lt;- x^2+y^2 #calculando ## return(result) #valor a ser retornado ## } Outro exemplo, podemos transformar em uma função aquele script que faz um histograma e sobrepõe a curva da distribuição normal: curva&lt;-function(x){ m&lt;-mean(x,na.rm=TRUE) std&lt;-sd(x,na.rm=TRUE) hist(x, prob=TRUE) curve(dnorm(x, mean=m, sd=std), col=&quot;darkblue&quot;, lwd=2, add=TRUE, yaxt=&quot;n&quot;) } Usando a função: library(openxlsx) dados&lt;-read.xlsx(&quot;dados/pinguim.xlsx&quot;, sheet = 1, colNames = T) curva(dados$bill_length_mm) curva(dados$bill_depth_mm) curva(dados$flipper_length_mm) curva(dados$body_mass_g) Porque escrever funções? Uma função te força a escrever tudo em termos gerais. As funções são criadas para tarefas que serão repetidas várias vezes. Em vez de copiar e colar o código várias vezes fazendo as alterações necessárias, usar funções é uma maneira muito mais razoável de resolver o problema e, uma vez criada e debbugada, é muito mais prático de usar. Um desafio é que o return só aceita um único objeto, ou seja, funções no R só retornam uma única coisa. Quando precisa retornar mais de uma coisa, uma opção é o list(), recebe qualquer coisa. Outra coisa que pode ser feita é quebrar uma função grande em funções menores. O R permite que uma função chame outra, o que facilita em muito o processo de criação de funções complicadas. 6.2 Loops São processos interativos para realizar uma sequências de comandos até uma condição predeterminada. 6.2.1 for Uma comando para isso é o for() Para esse comando usamos um contador. Exemplo: i&lt;-1 for(i in 1:5) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Podemos vários comandos. Nesse os comandos são colocados entre{} i&lt;-1 for(i in 1:5){ print(i) print(i^2) print(&quot;teste&quot;) } ## [1] 1 ## [1] 1 ## [1] &quot;teste&quot; ## [1] 2 ## [1] 4 ## [1] &quot;teste&quot; ## [1] 3 ## [1] 9 ## [1] &quot;teste&quot; ## [1] 4 ## [1] 16 ## [1] &quot;teste&quot; ## [1] 5 ## [1] 25 ## [1] &quot;teste&quot; 6.2.2 while Outro comando é o while j&lt;-1 while(j&lt;6){ print(j) print(&quot;teste&quot;) j&lt;-j+1 } ## [1] 1 ## [1] &quot;teste&quot; ## [1] 2 ## [1] &quot;teste&quot; ## [1] 3 ## [1] &quot;teste&quot; ## [1] 4 ## [1] &quot;teste&quot; ## [1] 5 ## [1] &quot;teste&quot; 6.3 if e else Com os comandos if e else se uma condição for atendida é executada uma ação. Por exemplo: x&lt;-2 if(x==1) print(&quot;sim&quot;) else print(&quot;não&quot;) ## [1] &quot;não&quot; Podemos usar o if e else dentro de um loop: i&lt;-1 for(i in 1:10){ if(i&lt;6) print(&quot;sim&quot;) else print(&quot;não&quot;) } ## [1] &quot;sim&quot; ## [1] &quot;sim&quot; ## [1] &quot;sim&quot; ## [1] &quot;sim&quot; ## [1] &quot;sim&quot; ## [1] &quot;não&quot; ## [1] &quot;não&quot; ## [1] &quot;não&quot; ## [1] &quot;não&quot; ## [1] &quot;não&quot; Agora vamos usar um loop para fazer o teste de chi-quadrado e torná-lo mais funcional. Nesse exemplo temos que montar um arquivo de entrada com as seguintes características: - o arquivo de entrada deve ter a primeira coluna identificando a comparação - os valores das duas colunas seguintes são os valores do primeiro grupo em seguida os valores do outro grupo - exemplo: grupo 1 tem 200 ind. com alelo 1 e 300 com alelo 2 e o grupo 2 tem 250 com alelo 1 350 com alelo 2, então: comp1 200 300 250 350 Vamos rodar um exemplo para isso vamos carregar o arquivo, transformar em matriz: dados4&lt;-read.xlsx(&quot;dados/quiquadrado.xlsx&quot;, sheet = 1, colNames = F,rowNames = T) dados5&lt;-as.matrix(dados4) dados5 ## X1 X2 X3 X4 ## comp1 372 950 244 450 ## comp2 244 850 260 780 ## comp3 510 970 490 950 Vamos criar um objeto (nomes) com os nomes das linhas. Agora vamos criar o loop, usando o comando for. O número de repetições do loop vai ser definido pelo número de elementos em nomes. Vamos armazenar os resultados em um arquivo txt: nomes&lt;-row.names(dados5) nomes ## [1] &quot;comp1&quot; &quot;comp2&quot; &quot;comp3&quot; i&lt;-1 for (i in nomes) { a&lt;-dados5[i,1] # linha i, coluna 1 b&lt;-dados5[i,2] # linha i, coluna 2 c&lt;-dados5[i,3] # linha i, coluna 3 d&lt;-dados5[i,4] # linha i, coluna 4 quadrado&lt;-rbind(c(a,c),c(b,d)) res_qui&lt;-chisq.test(quadrado,correct=F) write(i,file=&quot;resultados/resultado_quiquadrado.txt&quot;, append = T) capture.output(res_qui, file=&quot;resultados/resultado_quiquadrado.txt&quot;, append = T) } 6.4 Funções apply, lapply, sapply, tapply, mapply A família Apply representa um conjunto de funções básicas do R que permite realizar operações sobre os dados contidos nas várias estruturas disponíveis (vetor, data frame, listas). A utilização destas funções permitem automatizar a aplicação das operações desejadas, permitindo assim ganhos de velocidade durante procedimentos que necessitam ser repetidos sobre todos os dados. A função apply é para matriz library(dplyr) dados3&lt;-dados%&gt;% select(bill_length_mm:body_mass_g) dados3&lt;-as.matrix(dados3) apply(dados3, 2, mean, na.rm=T) # 2 indica colunas, 1 indica linhas ## bill_length_mm bill_depth_mm flipper_length_mm body_mass_g ## 43.92193 17.15117 200.91520 4201.75439 A função lapply é para lista: x&lt;-list(a = 1:4, b = rnorm(10), c = rnorm(20,1), d = rnorm(100,5)) x ## $a ## [1] 1 2 3 4 ## ## $b ## [1] -0.1462363 1.1329913 2.4079264 0.8440802 1.8885291 -1.5309676 ## [7] 0.7304055 -1.2286932 1.8829656 0.5071695 ## ## $c ## [1] 1.1307528 0.1606436 -0.0783188 1.6592956 2.5304673 -0.7101490 ## [7] 0.3305488 0.3119459 0.2144906 0.5243890 -0.3594519 -0.9596989 ## [13] 1.1986835 1.7080799 1.0791402 1.1761097 0.7434128 -0.2957054 ## [19] 0.7377619 0.4087309 ## ## $d ## [1] 4.987162 5.926693 5.123900 4.378592 4.231536 6.553934 3.703266 4.146679 ## [9] 3.682711 4.529510 4.878990 5.071106 5.428486 5.024510 3.286090 3.776374 ## [17] 4.367179 6.075260 6.586768 5.191323 4.959922 4.710876 6.579611 5.190614 ## [25] 4.349555 6.711560 7.670846 5.056228 5.651544 5.481577 5.418695 5.314562 ## [33] 3.749451 6.650012 4.480169 3.967190 3.340270 6.305455 5.190831 4.959075 ## [41] 5.124409 6.011343 4.396762 4.833261 3.975135 6.206448 3.437240 6.350211 ## [49] 4.110012 6.236525 8.267206 5.628478 5.075394 4.609689 5.738808 4.983893 ## [57] 5.240769 5.594473 6.245396 4.209579 5.379996 4.838167 6.219653 5.428798 ## [65] 6.390918 5.222443 3.840240 5.770810 4.687458 4.711948 3.464836 5.814927 ## [73] 3.223144 6.755132 5.154703 5.021050 6.232634 5.366411 5.533100 6.266400 ## [81] 5.635938 5.896446 5.166291 4.976217 6.404555 5.893115 5.587616 5.360103 ## [89] 4.356734 5.684694 2.997125 4.673638 4.378489 4.450108 7.401493 5.236328 ## [97] 5.062635 4.463701 5.840819 5.813454 lapply(x, mean) ## $a ## [1] 2.5 ## ## $b ## [1] 0.648817 ## ## $c ## [1] 0.5755564 ## ## $d ## [1] 5.195654 A função sapply é parecida com lapply, mas retorna vetor ou matriz: sapply(x, mean) ## a b c d ## 2.5000000 0.6488170 0.5755564 5.1956540 A função tapply é utilizada para aplicar um procedimento a diferentes partes dos dados dentro de um array, matriz ou data frame. Ela difere das demais funções vistas até aqui por exigir a existência de uma variável categórica, a qual servirá para agrupar os dados aos diferentes níveis. tapply(dados$bill_length_mm, dados$sex, mean, na.rm=T) ## female male ## 42.09697 45.85476 A função mapply é uma versão multivariada da função lapply. As funções lapply e sapply atuam somente sobre os elementos de uma única lista. No caso da função mapply a função é aplicada sobre o primeiro elemento de cada um dos argumentos, em seguida ao segundo elemento, seguindo ao terceiro, e assim por diante. mapply(sum, dados$bill_length_mm, dados$bill_depth_mm) ## [1] 57.8 56.9 58.3 NA 56.0 59.9 56.7 58.8 52.2 62.2 54.9 55.1 58.7 59.8 55.7 ## [16] 54.4 57.7 63.2 52.8 67.5 56.1 56.4 55.1 56.3 56.0 54.2 59.2 58.4 56.5 59.4 ## [31] 56.2 55.3 57.3 59.8 53.4 60.3 58.8 60.7 56.9 58.9 54.5 59.2 54.5 63.8 53.9 ## [46] 58.4 60.1 56.4 53.9 63.5 57.3 59.0 52.9 61.5 52.6 60.0 56.5 59.4 53.1 56.7 ## [61] 52.6 62.4 54.6 59.3 53.5 59.6 51.7 60.2 52.5 61.2 52.5 58.1 56.8 64.7 53.0 ## [76] 61.3 57.7 56.6 52.3 61.2 51.8 60.5 55.5 54.5 55.1 61.6 55.8 55.5 57.5 57.7 ## [91] 53.7 59.2 51.1 57.7 53.5 59.7 56.7 58.8 49.2 61.7 52.9 61.0 53.7 57.8 56.5 ## [106] 58.6 55.8 58.2 55.1 62.2 54.6 65.9 57.4 61.7 60.3 61.0 55.6 57.8 52.7 59.7 ## [121] 53.4 57.5 57.2 59.9 51.1 59.6 56.4 59.8 56.1 62.1 56.4 62.3 55.3 56.0 55.7 ## [136] 58.6 53.1 60.3 53.5 57.6 57.3 57.8 47.6 57.7 54.1 57.7 57.8 55.0 53.8 55.9 ## [151] 53.1 60.0 59.3 66.3 62.8 65.2 62.1 60.0 60.0 62.0 56.7 62.2 54.6 65.1 59.2 ## [166] 63.0 60.4 65.0 55.5 64.4 60.7 63.8 64.5 59.6 61.0 62.1 56.0 61.2 58.8 62.8 ## [181] 62.5 65.3 62.6 57.0 59.6 76.6 63.9 64.7 56.3 61.7 57.6 64.4 56.4 65.6 59.0 ## [196] 64.6 66.4 57.5 59.4 66.4 58.2 61.0 60.8 62.6 59.5 65.1 60.9 60.4 57.7 60.5 ## [211] 57.7 65.7 59.1 61.1 59.6 70.0 60.0 66.6 60.6 65.7 57.7 65.7 62.7 62.0 63.8 ## [226] 61.3 61.4 64.6 61.7 67.4 59.0 61.6 63.6 68.1 62.0 65.9 58.7 68.1 57.8 65.5 ## [241] 61.5 69.1 62.5 69.3 60.0 65.6 59.2 66.5 65.2 61.5 62.8 67.6 63.5 72.9 62.7 ## [256] 64.1 61.1 62.9 56.4 69.2 57.3 63.2 65.7 65.7 58.7 67.8 60.3 71.1 60.2 65.0 ## [271] 60.9 NA 61.1 66.1 60.0 66.0 64.4 69.5 70.5 64.1 72.5 63.0 64.3 69.5 64.9 ## [286] 71.2 64.4 72.0 64.3 70.1 63.0 70.1 70.3 75.8 65.0 67.4 59.7 66.0 59.8 70.0 ## [301] 64.6 71.0 68.9 68.5 64.2 72.8 57.5 75.0 59.2 69.8 68.3 64.3 65.9 72.7 63.5 ## [316] 73.4 68.5 63.7 70.0 62.5 68.8 69.3 68.0 68.6 70.2 67.1 64.5 70.4 63.0 70.4 ## [331] 59.8 71.0 61.8 69.2 69.0 65.0 71.4 63.3 62.7 75.6 61.6 67.8 69.8 68.9 "],["genética.html", "Capítulo 7 Genética 7.1 Genética de populações 7.2 Genotipagem com genetics e loop 7.3 Heredogramas 7.4 Análises filogenéticas", " Capítulo 7 Genética 7.1 Genética de populações No estudo de genética de populações, alguns cálculos básicos são as frequências alélicas e genotípicas, verificar se está em equilíbrio de Hardy-Weinberg e também verificar o desequilíbrio de ligação. Esses cálculos podem ser feitos com o pacote genetics. Vamos carregar alguns dados de exemplo: dados&lt;-read.table(&quot;dados/genotipagem.txt&quot;, head=T) head(dados) ## AMOSTRAS rs1800977 rs2230806 rs3764650 rs2279796 rs692383 rs3827225 grupo ## 1 AHC01 G/G C/C G/T A/G A/G G/G 1 ## 2 AHC02 G/G C/T G/T G/G A/A A/G 1 ## 3 AHC03 G/G T/T T/T A/G A/A G/G 1 ## 4 AHC04 A/A C/C T/T G/G A/G A/G 1 ## 5 AHC06 A/G C/C T/T A/A A/A A/A 1 ## 6 AHC07 A/G C/C T/T A/G A/G A/A 1 Vamos carregar o pacote genetics: library(genetics) snp&lt;-&quot;rs1800977&quot; #substituir pelo gene/SNP de interesse Agora vamos usar a função genotype, onde em sep informamos o separador de alelos nos dados. genotipos1&lt;-na.omit(genotype(dados$rs1800977, sep=&quot;/&quot;)) genotipos1 ## [1] &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; ## [13] &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/G&quot; ## [25] &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; ## [37] &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; ## [49] &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; ## [61] &quot;A/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; ## [73] &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; ## [85] &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [97] &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; ## [109] &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; ## [121] &quot;A/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; ## [133] &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; ## [145] &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; ## [157] &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; ## [169] &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [181] &quot;G/G&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [193] &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; ## [205] &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [217] &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; ## [229] &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; ## [241] &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [253] &quot;G/A&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; ## [265] &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;A/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; ## [277] &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;G/A&quot; ## [289] &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;A/A&quot; &quot;A/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; ## [301] &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/A&quot; ## [313] &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/A&quot; &quot;G/G&quot; &quot;G/G&quot; &quot;G/A&quot; &quot;G/A&quot; ## [325] &quot;A/A&quot; ## Alleles: G A Podemos ver os resultados de frequências usando summary: resultado1&lt;-summary(genotipos1) resultado1 ## ## Number of samples typed: 325 (100%) ## ## Allele Frequency: (2 alleles) ## Count Proportion ## G 430 0.66 ## A 220 0.34 ## ## ## Genotype Frequency: ## Count Proportion ## G/G 135 0.42 ## G/A 160 0.49 ## A/A 30 0.09 ## ## Heterozygosity (Hu) = 0.4485007 ## Poly. Inf. Content = 0.3475435 Para verificar o equilíbrio de Hardy-Weinberg usamos a função HWE.chisq: eqhw1&lt;-HWE.chisq(genotipos1) eqhw1 ## ## Pearson&#39;s Chi-squared test with simulated p-value (based on 10000 ## replicates) ## ## data: tab ## X-squared = 3.2089, df = NA, p-value = 0.08419 Podemos salvar os resultados em um arquivo txt, onde vamos usar o objeto snp para especificar de qual SNP são os resultados: write(&quot;Frequencias alelicas e genotipicas.&quot;, file=&quot;res.genes.txt&quot;,append=T) write(snp, file=&quot;res.genes.txt&quot;, append=T) capture.output(resultado1, file=&quot;res.genes.txt&quot;,append = T) capture.output(eqhw1, file=&quot;res.genes.txt&quot;, append = T) Também podemos gerar figuras com as frequências: plot(genotipos1, type=&quot;allele&quot;, what=&quot;percentage&quot;) plot(genotipos1, type=&quot;genotype&quot;, what=&quot;percentage&quot;) Para salvar as figuras com as frequências, onde filename=paste(snp,“alelo.jpg”, sep=““: serve para criar o nome do arquivo juntando o conteúdo de snp + alelo.jpg, sem espaço, definido por sep sem nada: jpeg(filename=paste(snp,&quot;alelo.jpg&quot;, sep=&quot;&quot;)) plot(genotipos1, type=&quot;allele&quot;, what=&quot;percentage&quot;) dev.off() ## png ## 2 jpeg(filename=paste(snp,&quot;genotipo.jpg&quot;, sep=&quot;&quot;)) plot(genotipos1, type=&quot;genotype&quot;, what=&quot;percentage&quot;) dev.off() ## png ## 2 Desequilíbrio de ligação Também podemos calcular o desequilíbrio de ligação entre 2 SNPs com a função LD, mas primeiro criamos os objetos com os dados dos SNPs com a função genotype: rs1800977&lt;-na.omit(genotype(dados$rs1800977, sep=&quot;/&quot;)) rs2230806&lt;-na.omit(genotype(dados$rs2230806, sep=&quot;/&quot;)) ld&lt;-LD(rs1800977,rs2230806) ld ## ## Pairwise LD ## ----------- ## D D&#39; Corr ## Estimates: -0.01494381 0.146423 -0.06881552 ## ## X^2 P-value N ## LD Test: 3.078125 0.07935198 325 7.2 Genotipagem com genetics e loop Vamos juntar os conhecimentos de loops, que já aprendemos, para genotipar vários SNPs e criar um arquivo de saída mais elaborado: No arquivo que estamos usando, tem uma coluna grupo (caso e controle). Usaremos essa coluna para criar 2 objetos: library(dplyr) caso&lt;-filter(dados, grupo==1) controle&lt;-filter(dados, grupo==2) Precisamos detalhar o que tem em resultados1: names(resultado1) ## [1] &quot;allele.names&quot; &quot;allele.freq&quot; &quot;genotype.freq&quot; &quot;Hu&quot; ## [5] &quot;pic&quot; &quot;n.typed&quot; &quot;n.total&quot; &quot;nallele&quot; Em allele.fre e genotype.freq temos uma matriz com os resultados: resultado1$allele.freq ## Count Proportion ## G 430 0.6615385 ## A 220 0.3384615 resultado1$genotype.freq ## Count Proportion ## G/G 135 0.41538462 ## G/A 160 0.49230769 ## A/A 30 0.09230769 Com base nisso, precisamos definir quais dados queremos salvar e criar uma tabela com as variáveis. Aqui criamos o objeto tabela.saida, que é um data.frame e especificamos as colunas: tabela.saida&lt;-data.frame(grupo=as.character(NA),SNP=as.character(NA),genot1=as.character(NA), N1=NA, F1=NA,genot2=as.character(NA), N2=NA, F2=NA,genot3=as.character(NA),N3=NA,F3=NA,alelo1=as.character(NA),N4=NA,F4=NA,alelo2=as.character(NA),N5=NA,F5=NA,hw=NA,qui_genot=NA,qui_alel=NA,stringsAsFactors = F) Agora vamos criar o loop, usando for, para fazer a genotipagem e equilíbrio de HW, de cada SNP, no grupo caso e no grupo controle, depois compare por qui-quadrado as frequências alélicas e genotípica entre casos e controles. nomes&lt;-colnames(dados) #nomes dos SNPs i&lt;-2 #número da coluna inicial para genotipar snp&lt;-7 # número da coluna final para genotipar j&lt;-1 for (i in i:snp) { nome_snp&lt;-nomes[i] genotipos1&lt;-na.omit(genotype(caso[,i], sep=&quot;/&quot;))#genotipagem resultado1&lt;-summary(genotipos1)#sumariza resultados eqhw1&lt;-HWE.chisq(genotipos1)#equilíbrio de HW nome_genot&lt;-rownames(resultado1$genotype.freq) nome_alelos&lt;-rownames(resultado1$allele.freq) tabela.saida[j,]&lt;-data.frame(grupo=as.character(&quot;caso&quot;),SNP=as.character(nome_snp),genot1=as.character(nome_genot[1]), N1=resultado1$genotype.freq[1,1], F1=resultado1$genotype.freq[1,2],genot2=as.character(nome_genot[2]), N2=resultado1$genotype.freq[2,1],F2=resultado1$genotype.freq[2,2], genot3=as.character(nome_genot[3]),N3=resultado1$genotype.freq[3,1],F3=resultado1$genotype.freq[3,2],alelo1=as.character(nome_alelos[1]),N4=resultado1$allele.freq[1,1],F4=resultado1$allele.freq[1,2],alelo2=as.character(nome_alelos[2]),N5=resultado1$allele.freq[2,1],F5=resultado1$allele.freq[2,2],hw=eqhw1$p.value,qui_genot=NA,qui_alel=NA,stringsAsFactors = F) j&lt;-j+1 genotipos2&lt;-na.omit(genotype(controle[,i], sep=&quot;/&quot;))#genotipagem resultado2&lt;-summary(genotipos2)#sumariza resultados eqhw2&lt;-HWE.chisq(genotipos2)#equilíbrio de HW #qui-quadrado alelo a&lt;-resultado1$allele.freq[1,1] b&lt;-resultado1$allele.freq[2,1] c&lt;-resultado2$allele.freq[1,1] d&lt;-resultado2$allele.freq[2,1] quadrado&lt;-rbind(c(a,c),c(b,d)) quadrado res_qui&lt;-chisq.test(quadrado,correct=F) #qui-quadrado genotipo g&lt;-resultado1$genotype.freq[1,1] h&lt;-resultado1$genotype.freq[2,1] l&lt;-resultado1$genotype.freq[3,1] k&lt;-resultado2$genotype.freq[1,1] m&lt;-resultado2$genotype.freq[2,1] o&lt;-resultado2$genotype.freq[3,1] quadrado2&lt;-rbind(c(g,k),c(h,m),c(l,o)) res_qui2&lt;-chisq.test(quadrado2,correct=F) tabela.saida[j,]&lt;-data.frame(grupo=as.character(&quot;controle&quot;),SNP=as.character(nome_snp),genot1=as.character(nome_genot[1]), N1=resultado2$genotype.freq[1,1], F1=resultado2$genotype.freq[1,2],genot2=as.character(nome_genot[2]), N2=resultado2$genotype.freq[2,1],F2=resultado2$genotype.freq[2,2], genot3=as.character(nome_genot[3]),N3=resultado2$genotype.freq[3,1],F3=resultado2$genotype.freq[3,2],alelo1=as.character(nome_alelos[1]),N4=resultado2$allele.freq[1,1],F4=resultado2$allele.freq[1,2],alelo2=as.character(nome_alelos[2]),N5=resultado2$allele.freq[2,1],F5=resultado2$allele.freq[2,2],hw=eqhw2$p.value,qui_genot=res_qui2$p.value,qui_alel=res_qui$p.value,stringsAsFactors = F) i&lt;-(i+1) j&lt;-j+1 } Verificando os resultados: library(flextable) flextable(tabela.saida) .cl-84dbebe0{}.cl-84cd83ac{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-84d2d5e6{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-84d2d5fa{margin:0;text-align:right;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-84d2fc38{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84d2fc4c{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84d2fc4d{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84d2fc56{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84d2fc60{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-84d2fc6a{width:0.75in;background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}grupoSNPgenot1N1F1genot2N2F2genot3N3F3alelo1N4F4alelo2N5F5hwqui_genotqui_alelcasors1800977G/G790.4030612G/A960.4897959A/A210.10714286G2540.6479592A1380.35204080.3501650controlers1800977G/G560.4341085G/A640.4961240A/A90.06976744G1760.6821705A820.31782950.10658930.50555720.3671365casors2230806C/C910.4642857C/T900.4591837T/T150.07653061C2720.6938776T1200.30612240.3173683controlers2230806C/C670.5193798C/T480.3720930T/T140.10852713C1820.7054264T760.29457360.29207080.25057530.7535973casors3764650T/T1350.7758621T/G360.2068966G/G30.01724138T3060.8793103G420.12068971.0000000controlers3764650T/T790.8061224T/G160.1632653G/G30.03061224T1740.8877551G220.11224490.10428960.54735380.7691475casors2279796A/A550.2777778A/G910.4595960G/G520.26262626A2010.5075758G1950.49242420.2571743controlers2279796A/A310.2460317A/G690.5476190G/G260.20634921A1310.5198413G1210.48015870.28207180.28458270.7607357casors692383A/A830.4234694A/G850.4336735G/G280.14285714A2510.6403061G1410.35969390.4345565controlers692383A/A530.4140625A/G590.4609375G/G160.12500000A1650.6445312G910.35546881.00000000.84889220.9126687casors3827225G/G1030.5282051G/A760.3897436A/A160.08205128G2820.7230769A1080.27692310.7174283controlers3827225G/G740.5692308G/A490.3769231A/A70.05384615G1970.7576923A630.24230770.62773720.56236750.3261360 Para terminar vamos salvar os resultados em um arquivo xlsx: library(openxlsx) write.xlsx(tabela.saida, file=&quot;genotipagem.xlsx&quot;) 7.3 Heredogramas Também podemos gerar heredogramas usando o R, para isso usamos o pacote kinship2 e carregar o arquivo de exemplo: library(kinship2) familia&lt;-read.xlsx(&quot;dados/familia.xlsx&quot;, sheet=1, colNames = T) head(familia) ## ids dad mom sex dead caract ## 1 1 NA NA 1 0 0 ## 2 2 NA NA 2 1 0 ## 3 3 NA NA 1 0 0 ## 4 4 1 2 2 0 0 ## 5 5 1 2 1 0 0 ## 6 6 NA NA 2 0 0 Nessa planilha temos uma coluna com a identificação única de de cada indivíduo (ids), duas colunas identificando os pais (dad e mom), uma coluna para o sexo, uma coluna com a informação se o indivíduo está vivo ou não (dead) e uma última coluna (caract) que indica se o indivíduo tem a característica de interesse. Usando a função pedigree: family &lt;- pedigree(id=familia$ids, dadid=familia$dad, momid=familia$mom, affected=familia$caract, sex=familia$sex, status=familia$dead) E plotando o heredograma: plot.pedigree(family,cex = 0.8, col = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;)) 7.4 Análises filogenéticas O pacote APE (Analysis of Phylogenetics and Evolution) permite fazer vários tipos de análises (http://ape-package.ird.fr/). Podemos pegar sequências de DNA diretamente do Genbank: library(ape) id_seq&lt;-c(&quot;NM_001081850.1&quot;,&quot;NM_000055.3&quot;,&quot;NM_009738.3&quot;) seq_bche&lt;-read.GenBank(id_seq) seq_bche ## 3 DNA sequences in binary format stored in a list. ## ## Mean sequence length: 3495.333 ## Shortest sequence: 1809 ## Longest sequence: 6209 ## ## Labels: ## NM_001081850.1 ## NM_000055.3 ## NM_009738.3 ## ## Base composition: ## a c g t ## 0.315 0.192 0.194 0.299 ## (Total: 10.49 kb) Também é possível ler um arquivo fasta: pon&lt;-read.FASTA(&quot;dados/PON123.fas&quot;) pon ## 13 DNA sequences in binary format stored in a list. ## ## All sequences of same length: 1065 ## ## Labels: ## PON1Hsapie ## PON1Ptrogl ## PON1Mmulat ## PON1Mmuscu ## PON2Hsapie ## PON2Ptrogl ## ... ## ## Base composition: ## a c g t ## 0.284 0.215 0.228 0.274 ## (Total: 13.85 kb) E com a função nj podemos fazer uma árvore pelo método neighbor-joining de Saitou and Nei (1987). pon.trw&lt;-nj(dist.dna(pon)) plot(pon.trw) "],["network.html", "Capítulo 8 Network 8.1 Pacote Igraph", " Capítulo 8 Network Em várias áreas temos dados complexos de interações entre diferentes grupos de elementos que estão sendo analisados e para esses casos, um gráfico de rede ajuda a visualizar essas interações, que podem ser espécies, genes ou pessoas. Conceitos básicos: Vértices (Vertices) e arestas (edges) Vértices: é um ponto em que duas ou mais curvas, retas ou arestas se encontram. Arestas: segmento de reta que liga dois vértices. Os objetos para fazer uma rede é uma matriz de adjacências, que é uma matriz quadrada, onde os nomes das linha e colunas são os vértices e os valores dentro da matriz indicam uma conexão (1) dos vértices ou não (0). No entanto, podemos criar um objeto para rede a partir de um dataframe, como veremos depois. 8.1 Pacote Igraph Um dos principais pacotes para criar gráficos de redes é o igraph, cujo manual pode ser consultado em https://igraph.org/r/ Existem muitas funções para criar diferentes estruturas de gráficos no Igraph. Conceitos básicos: Vértices (Vertices) e arestas (edges) Vértices: é um ponto em que duas ou mais curvas, retas ou arestas se encontram Arestas: segmento de reta que liga dois vértices Exemplo: library(igraph) g&lt;-graph.full(n=10, directed = FALSE, loops = F) plot(g) Gráfico completo: cada par de vértices tem uma aresta conectando-os, o argumento LOOPS = FALSE significa que as arestas próprias não são adicionadas. Gráficos com a lista de arestas (edges) fornecida: edges &lt;- c(1,2, 3,2, 2,4) g&lt;-graph(edges, n=max(edges), directed=TRUE) plot(g) Podemos montar um arquivo com os vértices e arestas library(openxlsx) arestas&lt;-read.xlsx(&quot;dados/miRNA2.xlsx&quot;, sheet=1,colNames = T) vertices&lt;-read.xlsx(&quot;dados/miRNA2.xlsx&quot;, sheet=2,colNames = T) head(arestas) ## from to weight type ## 1 1 23 1 3UTR ## 2 1 24 1 3UTR ## 3 1 25 1 3UTR ## 4 1 26 1 3UTR ## 5 1 27 1 3UTR ## 6 2 25 1 3UTR head(vertices) ## id nome tipo type.label ## 1 1 miRNA1 1 miRNA ## 2 2 miRNA2 1 miRNA ## 3 3 miRNA3 1 miRNA ## 4 4 miRNA4 1 miRNA ## 5 5 miRNA5 1 miRNA ## 6 6 miRNA6 1 miRNA Vamos criar o objet net com a função graph_from_data: net &lt;- graph_from_data_frame(arestas, directed=T) net ## IGRAPH 87ac1db DNW- 27 51 -- ## + attr: name (v/c), weight (e/n), type (e/c) ## + edges from 87ac1db (vertex names): ## [1] 1 -&gt;23 1 -&gt;24 1 -&gt;25 1 -&gt;26 1 -&gt;27 2 -&gt;25 2 -&gt;26 3 -&gt;23 3 -&gt;27 4 -&gt;24 ## [11] 4 -&gt;25 4 -&gt;26 5 -&gt;26 5 -&gt;27 6 -&gt;24 6 -&gt;26 6 -&gt;27 7 -&gt;24 7 -&gt;27 8 -&gt;24 ## [21] 8 -&gt;26 9 -&gt;24 9 -&gt;25 10-&gt;23 10-&gt;26 10-&gt;27 11-&gt;24 11-&gt;25 12-&gt;24 12-&gt;26 ## [31] 13-&gt;24 13-&gt;26 13-&gt;27 14-&gt;25 14-&gt;27 15-&gt;24 15-&gt;27 16-&gt;25 16-&gt;26 17-&gt;25 ## [41] 17-&gt;26 18-&gt;24 18-&gt;27 19-&gt;25 19-&gt;27 20-&gt;25 20-&gt;27 21-&gt;24 21-&gt;26 22-&gt;24 ## [51] 22-&gt;26 E gerar o gráfico: plot(net, edge.arrow.size=.2,vertex.label=vertices$nome, vertex.label.color=&quot;blue&quot;, vertex.label.dist=3, vertex.size=5) Podemos ainda mudar configurações: l &lt;- layout_with_kk(net) l &lt;- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1) plot(net, rescale=F, layout=l*1.2, edge.arrow.size=.2,vertex.label=vertices$nome, vertex.label.color=vertices$tipo, vertex.label.dist=3, vertex.size=5, vertex.color=vertices$tipo) "],["bioconductor.html", "Capítulo 9 Bioconductor 9.1 Pacote msa 9.2 Pacote multiMiR", " Capítulo 9 Bioconductor O projeto Bioconductor desenvolve, apoia e dissemina software de código aberto gratuito que facilite a análise rigorosa e reprodutível de dados de ensaios biológicos atuais e emergentes. Conta com mais de 2000 pacotes. A versão atual (3.17) requer a versão 4.3.0 do R. Para instalar pacotes do Bioconductor precisa do pacote BiocManager: if (!require(“BiocManager”, quietly = TRUE)) install.packages(“BiocManager”) BiocManager::install(version = “3.16”) Depois os pacotes podem ser instalados assim: BiocManager::install(c(“GenomicFeatures”, “AnnotationDbi”)) Para procurar pacotes: BiocManager::available(&quot;expression&quot;) ## [1] &quot;easyDifferentialGeneCoexpression&quot; &quot;ExpressionAtlas&quot; ## [3] &quot;ExpressionNormalizationWorkflow&quot; &quot;geneExpressionFromGEO&quot; ## [5] &quot;GeneExpressionSignature&quot; &quot;lungExpression&quot; ## [7] &quot;maqcExpression4plex&quot; &quot;NormExpression&quot; ## [9] &quot;RVerbalExpressions&quot; &quot;statsExpressions&quot; O site é: https://bioconductor.org/ 9.1 Pacote msa Vamos instalar o pacote msa (Multiple Sequence Alignment): An R Package for Multiple Sequence Alignment Enrico Bonatesta, Christoph Kainrath, and Ulrich Bodenhofer Institute of Bioinformatics, Johannes Kepler University Linz, Austria BiocManager::install(“msa”) Vamos carregar algumas sequências usando o pacote ape: library(ape) id_seq&lt;-c(&quot;NM_022942.1&quot;,&quot;NM_009738.3&quot;,&quot;NM_001313861.2&quot;) seq_bche&lt;-read.GenBank(id_seq) seq_bche ## 3 DNA sequences in binary format stored in a list. ## ## Mean sequence length: 3435 ## Shortest sequence: 1878 ## Longest sequence: 6209 ## ## Labels: ## NM_022942.1 ## NM_009738.3 ## NM_001313861.2 ## ## Base composition: ## a c g t ## 0.310 0.201 0.197 0.292 ## (Total: 10.3 kb) Temos que salvar em formato fasta, para depois usar esse arquivo no msa. O formato FASTA é um formato baseado em texto para representar tanto sequencias de nucleotideos quanto sequencias de aminoácidos. O formato também permite sequências de nomes e comentários precedendo as sequências. write.FASTA(seq_bche, file = &quot;seq_bche.fasta&quot;) Agora vamos fazer o alinhamento usando o pacote msa, onde informamos o tipo de sequência em type (pode ser dna,rna ou protein), em method escolhemos o método de alinhamento, sendo as opções: “ClustalW”, “ClustalOmega” e “Muscle”. Iremos utilizar o ClustalW. library(msa) alin&lt;-msa(&quot;seq_bche.fasta&quot;, type = &quot;dna&quot;, method = &quot;ClustalW&quot;) ## use default substitution matrix alin ## CLUSTAL 2.1 ## ## Call: ## msa(&quot;seq_bche.fasta&quot;, type = &quot;dna&quot;, method = &quot;ClustalW&quot;) ## ## MsaDNAMultipleAlignment with 3 rows and 6219 columns ## aln ## [1] ------------------------------------...------------------------------------ ## [2] CTTCTCTCCTGAAGCCTGCCTGCAATGGTGGAGGAA...GAATCATATGCACAAAATAAAAACTTCCTTGTATAA ## [3] ------------------------------------...------------------------------------ ## Con ------------------------------------...------------------------------------ Para ver o alinhamento vamos usar outro pacote, o ggmsa: instalar o pacote ggmsa BiocManager::install(“ggmsa”) Precisamos fazer algumas transformações no objeto alin antes de usar no ggmsa: library(ggmsa) # converter para o formato do ape ali_bche&lt;-msaConvert(alin, type=&quot;ape::DNAbin&quot;) # salvar no formato fasta write.FASTA(ali_bche, file = &quot;ali_bche.fas&quot;) # ler o arquivo fasta ali_bche2&lt;-read.FASTA(&quot;ali_bche.fas&quot;) Agora vamos gerar a figura com o alinhamento: ggmsa(ali_bche2, 1000, 1030, char_width = 0.5, seq_name = F) Acrescentando uma camada: ggmsa(ali_bche2, 1000, 1020, char_width = 0.5, seq_name = T) + geom_seqlogo(color = &quot;Chemistry_NT&quot;) Acrescentando a sequência consenso: ggmsa(ali_bche2, 1000, 1020, char_width = 0.8, seq_name = T) + geom_seqlogo(color = &quot;Chemistry_NT&quot;) + geom_msaBar() ## Coordinate system already present. Adding new coordinate system, which will ## replace the existing one. Esquema de cores ggmsa predefine vários esquemas de cores para renderização. Podemos usar available_msa() para listar os esquemas de cores disponíveis. Observe que aminoácidos (proteína) e nucleotídeos (DNA/RNA) têm nomes diferentes. DNA: Chemistry_NT Shapely_NT Taylor_NT Zappo_NT Proteínas: Clustal Chemistry_AA Shapely_AA Zappo_AA Taylor_AA LETTER CN6 Hydrophobicity Abaixo estão as camadas de anotação suportadas pelo ggmsa: Annotation modules Type Description geom_seqlogo() geometric layer automatically generated sequence logos for a MSA geom_GC() annotation module shows GC content with bubble chart geom_seed() annotation module highlights seed region on miRNA sequences geom_msaBar() annotation module shows sequences conservation by a bar chart geom_helix() annotation module depicts RNA secondary structure as arc diagrams(need extra data) 9.2 Pacote multiMiR Para insatalar: BiocManager::install(“multiMiR”) Os microRNAs (miRNAs) regulam a expressão promovendo a degradação ou reprimindo a tradução de transcritos alvo. Os sítios alvo de miRNA foram catalogados em bancos de dados com base em validação experimental e previsão computacional usando uma variedade de algoritmos. O pacote R multiMiR (http://multimir.org), é uma coleção abrangente de interações miRNA-alvo previstas e validadas e suas associações com doenças e medicamentos. O multiMiR inclui vários novos recursos não disponíveis em pacotes R existentes. As informações de cada banco de dados externo são armazenadas em uma tabela no banco de dados multiMiR. Para ver uma lista das tabelas, podemos usar a função multimir_dbTables(). library(multiMiR) ## Welcome to multiMiR. ## ## multiMiR database URL has been set to the ## default value: http://multimir.org/ ## ## Database Version: 2.3.0 Updated: 2020-04-15 multimir_dbTables() ## [1] &quot;diana_microt&quot; &quot;elmmo&quot; &quot;map_counts&quot; &quot;map_metadata&quot; &quot;microcosm&quot; ## [6] &quot;mir2disease&quot; &quot;miranda&quot; &quot;mirdb&quot; &quot;mirecords&quot; &quot;mirna&quot; ## [11] &quot;mirtarbase&quot; &quot;pharmaco_mir&quot; &quot;phenomir&quot; &quot;pictar&quot; &quot;pita&quot; ## [16] &quot;tarbase&quot; &quot;target&quot; &quot;targetscan&quot; Podemos ver os detalhes de cada banco: multimir_dbInfo() ## map_name source_name source_version source_date ## 1 diana_microt DIANA-microT 5 Sept, 2013 ## 2 elmmo EIMMo 5 Jan, 2011 ## 3 microcosm MicroCosm 5 Sept, 2009 ## 4 mir2disease miR2Disease Mar 14, 2011 ## 5 miranda miRanda Aug, 2010 ## 6 mirdb miRDB 6 June, 2019 ## 7 mirecords miRecords 4 Apr 27, 2013 ## 8 mirtarbase miRTarBase 7.0 Sept, 2017 ## 9 pharmaco_mir Pharmaco-miR (Verified Sets) ## 10 phenomir PhenomiR 2 Feb 15, 2011 ## 11 pictar PicTar 2 Dec 21, 2012 ## 12 pita PITA 6 Aug 31, 2008 ## 13 tarbase TarBase 8 2018 ## 14 targetscan TargetScan 7.2 March, 2018 ## source_url ## 1 http://diana.imis.athena-innovation.gr/DianaTools/index.php?r=microT_CDS/index ## 2 http://www.mirz.unibas.ch/miRNAtargetPredictionBulk.php ## 3 http://www.ebi.ac.uk/enright-srv/microcosm/cgi-bin/targets/v5/download.pl ## 4 http://www.mir2disease.org ## 5 http://www.microrna.org/microrna/getDownloads.do ## 6 http://mirdb.org ## 7 http://mirecords.biolead.org/download.php ## 8 http://mirtarbase.mbc.nctu.edu.tw/php/download.php ## 9 http://www.pharmaco-mir.org/home/download_VERSE_db ## 10 http://mips.helmholtz-muenchen.de/phenomir/ ## 11 http://dorina.mdc-berlin.de ## 12 http://genie.weizmann.ac.il/pubs/mir07/mir07_data.html ## 13 http://carolina.imis.athena-innovation.gr/diana_tools/web/index.php?r=tarbasev8%2Findex ## 14 http://www.targetscan.org/cgi-bin/targetscan/data_download.cgi?db=vert_61 Entre os 14 bancos de dados externos, oito contêm interações miRNA-alvo previstas, três têm interações miRNA-alvo validadas experimentalmente e os três restantes contêm associações miRNA-droga/doença. Para verificar essas categorias e bancos de dados de dentro do R, temos um conjunto de quatro funções auxiliares: predicted_tables() ## [1] &quot;diana_microt&quot; &quot;elmmo&quot; &quot;microcosm&quot; &quot;miranda&quot; &quot;mirdb&quot; ## [6] &quot;pictar&quot; &quot;pita&quot; &quot;targetscan&quot; validated_tables() ## [1] &quot;mirecords&quot; &quot;mirtarbase&quot; &quot;tarbase&quot; diseasedrug_tables() ## [1] &quot;mir2disease&quot; &quot;pharmaco_mir&quot; &quot;phenomir&quot; reverse_table_lookup(&quot;targetscan&quot;) ## [1] &quot;predicted&quot; Para ver quantos registros existem nesses 14 bancos de dados externos, nos referimos à função multimir_dbCount. multimir_dbCount() ## map_name human_count mouse_count rat_count total_count ## 1 diana_microt 7664602 3747171 0 11411773 ## 2 elmmo 3959112 1449133 547191 5955436 ## 3 microcosm 762987 534735 353378 1651100 ## 4 mir2disease 2875 0 0 2875 ## 5 miranda 5429955 2379881 247368 8057204 ## 6 mirdb 1990425 1091263 199250 3280938 ## 7 mirecords 2425 449 171 3045 ## 8 mirtarbase 544588 50673 652 595913 ## 9 pharmaco_mir 308 5 0 313 ## 10 phenomir 15138 491 0 15629 ## 11 pictar 404066 302236 0 706302 ## 12 pita 7710936 5163153 0 12874089 ## 13 tarbase 433048 209831 1307 644186 ## 14 targetscan 13906497 10442093 0 24348590 A função list_multimir() listar todos os miRNAs únicos, genes alvo, drogas e doenças no banco de dados multiMiR. Uma opção para limitar o número de registros retornados foi adicionada para ajudar nos testes e na exploração. miRNAs&lt;- list_multimir(&quot;mirna&quot;, limit = 10) genes&lt;- list_multimir(&quot;gene&quot;, limit = 10) drugs&lt;- list_multimir(&quot;drug&quot;, limit = 10) diseases&lt;- list_multimir(&quot;disease&quot;, limit = 10) miRNAs ## mature_mirna_uid org mature_mirna_acc mature_mirna_id ## 1 7829 ath MIMAT0000184 ath-miR163 ## 2 7833 ath MIMAT0000201 ath-miR170-3p ## 3 7831 ath MIMAT0000206 ath-miR173-5p ## 4 7828 ath MIMAT0001001 ath-miR400 ## 5 7837 ath MIMAT0001004 ath-miR403-3p ## 6 7830 ath MIMAT0001011 ath-miR408-3p ## 7 7838 ath MIMAT0003931 ath-miR472-3p ## 8 7846 ath MIMAT0003933 ath-miR774a ## 9 7839 ath MIMAT0003934 ath-miR775 ## 10 7841 ath MIMAT0003937 ath-miR778 genes ## target_uid org target_symbol target_entrez target_ensembl ## 1 112854 ath AT1G02860 ## 2 112855 ath AT1G06180 ## 3 112856 ath AT1G06580 ## 4 112857 ath AT1G15125 ## 5 112868 ath At1g31280 ## 6 112869 ath At1g50055 ## 7 112870 ath At1g51480 ## 8 112871 ath At1g53290 ## 9 112872 ath At1g62720 ## 10 112873 ath At1g62930 drugs ## drug ## 1 3,3&#39;-diindolylmethane ## 2 5-fluoroucil ## 3 abt-737 ## 4 alitretinoin ## 5 arabinocytosine ## 6 arsenic trioxide ## 7 azd6244 ## 8 bleomycin ## 9 butyrate ## 10 calcitriol diseases ## disease ## 1 ACTH-INDEPENDENT MACRONODULAR ADRENAL HYPERPLASIA; AIMAH ## 2 ACUTE LYMPHOBLASTIC LEUKEMIA (ALL) ## 3 ACUTE MYELOGENEOUS LEUKEMIA (AML) ## 4 ACUTE MYELOID LEUKEMIA (AML) ## 5 ACUTE PROMYELOCYTIC LEUKEMIA (APL) ## 6 ADENOMA ## 7 ADENOMAS, MULTIPLE COLORECTAL ## 8 ADRENOCORTICAL CARCINOMA ## 9 ALCOHOLIC LIVER DISEASE (ALD) ## 10 ALZHEIMER&#39;S DISEASE ## 11 ALZHEIMER DISEASE, SUSCEPTIBILITY TO ## 12 AMYOTROPHIC LATERAL SCLEROSIS, SUSCEPTIBILITY TO ## 13 ANAPLASTIC THYROID CARCINOMA (ATC) ## 14 ANXIETY DISORDER ## 15 ASTHMA ## 16 AUTISM, SUSCEPTIBILITY TO ## 17 BECKER MUSCULAR DYSTROPHY ## 18 BLADDER CANCER ## 19 BREAST CANCER ## 20 BURKITT LYMPHOMA get_multimir() é a principal função no pacote para recuperar interações miRNA-alvo previstas e validadas e suas associações de doenças e medicamentos do banco de dados multiMiR. Podemos pesquisar por miRNA: example1 &lt;- get_multimir(mirna = &#39;hsa-miR-125a-5p&#39;, summary = TRUE) ## Searching mirecords ... ## Searching mirtarbase ... ## Searching tarbase ... # Check which types of associations were returned table(example1@data$type) ## ## validated ## 1378 # Detailed information of the validated miRNA-target interaction head(example1@data) ## database mature_mirna_acc mature_mirna_id target_symbol target_entrez ## 1 mirecords MIMAT0000443 hsa-miR-125a-5p ERBB2 2064 ## 2 mirecords MIMAT0000443 hsa-miR-125a-5p ERBB3 2065 ## 3 mirecords MIMAT0000443 hsa-miR-125a-5p LIN28 ## 4 mirecords MIMAT0000443 hsa-miR-125a-5p LIN28 ## 5 mirecords MIMAT0000443 hsa-miR-125a-5p ARID3B 10620 ## 6 mirecords MIMAT0000443 hsa-miR-125a-5p TP53 7157 ## target_ensembl experiment ## 1 ENSG00000141736 Western blot//activity assay//Luciferase activity assay ## 2 ENSG00000065361 Western blot//activity assay//Luciferase activity assay ## 3 ENSG00000131914 ## 4 ENSG00000131914 ## 5 ENSG00000179361 Western blot ## 6 ENSG00000141510 Western blot ## support_type pubmed_id type ## 1 17110380 validated ## 2 17110380 validated ## 3 16227573 validated ## 4 16227573 validated ## 5 19881956 validated ## 6 19818772 validated Podemos pesquisar por medicamento: example2 &lt;- get_multimir(disease.drug = &#39;cisplatin&#39;, table = &#39;disease.drug&#39;) ## Searching mir2disease ... ## Searching pharmaco_mir ... ## Searching phenomir ... head(example2@data) ## database mature_mirna_acc mature_mirna_id target_symbol target_entrez ## 1 pharmaco_mir MIMAT0000772 hsa-miR-345-5p ABCC1 4363 ## 2 pharmaco_mir MIMAT0000720 hsa-miR-376c-3p ALK7 ## 3 pharmaco_mir MIMAT0000423 hsa-miR-125b-5p BAK1 578 ## 4 pharmaco_mir hsa-miR-34 BCL2 596 ## 5 pharmaco_mir MIMAT0000318 hsa-miR-200b-3p BCL2 596 ## 6 pharmaco_mir MIMAT0000617 hsa-miR-200c-3p BCL2 596 ## target_ensembl disease_drug paper_pubmedID type ## 1 ENSG00000103222 cisplatin 20099276 disease.drug ## 2 cisplatin 21224400 disease.drug ## 3 ENSG00000030110 cisplatin 21823019 disease.drug ## 4 ENSG00000171791 cisplatin 18803879 disease.drug ## 5 ENSG00000171791 cisplatin 21993663 disease.drug ## 6 ENSG00000171791 cisplatin 21993663 disease.drug Podemos pesquisar por gene: example3 &lt;- get_multimir(org = &quot;hsa&quot;, target = &quot;BCHE&quot;, table = &quot;predicted&quot;, summary = TRUE, predicted.cutoff = 35, predicted.cutoff.type = &quot;p&quot;, predicted.site = &quot;all&quot;) ## Searching diana_microt ... ## Searching elmmo ... ## Searching microcosm ... ## Searching miranda ... ## Searching mirdb ... ## Searching pictar ... ## Searching pita ... ## Searching targetscan ... table(example3@data$type) ## ## predicted ## 450 head(example3@data) ## database mature_mirna_acc mature_mirna_id target_symbol target_entrez ## 1 diana_microt MIMAT0015021 hsa-miR-3148 BCHE 590 ## 2 diana_microt MIMAT0015021 hsa-miR-3148 BCHE 590 ## 3 diana_microt MIMAT0022489 hsa-miR-5696 BCHE 590 ## 4 diana_microt MIMAT0022489 hsa-miR-5696 BCHE 590 ## 5 diana_microt MIMAT0019060 hsa-miR-4522 BCHE 590 ## 6 diana_microt MIMAT0019060 hsa-miR-4522 BCHE 590 ## target_ensembl score type ## 1 ENSG00000114200 0.998 predicted ## 2 ENSG00000114200 0.998 predicted ## 3 ENSG00000114200 0.974 predicted ## 4 ENSG00000114200 0.974 predicted ## 5 ENSG00000114200 0.971 predicted ## 6 ENSG00000114200 0.971 predicted head(example3@summary) ## mature_mirna_acc mature_mirna_id target_symbol target_entrez target_ensembl ## 1 MIMAT0004518 hsa-miR-16-2-3p BCHE 590 ENSG00000114200 ## 2 MIMAT0000275 hsa-miR-218-5p BCHE 590 ENSG00000114200 ## 3 MIMAT0003294 hsa-miR-625-5p BCHE 590 ENSG00000114200 ## 4 MIMAT0004615 hsa-miR-195-3p BCHE 590 ENSG00000114200 ## 5 MIMAT0004796 hsa-miR-576-3p BCHE 590 ENSG00000114200 ## 6 MIMAT0005937 hsa-miR-1279 BCHE 590 ENSG00000114200 ## diana_microt elmmo microcosm miranda mirdb pita targetscan predicted.sum ## 1 2 2 1 2 1 0 2 6 ## 2 0 2 1 1 0 1 1 5 ## 3 2 0 1 1 0 2 1 5 ## 4 2 2 0 2 1 0 2 5 ## 5 2 0 1 1 0 1 1 5 ## 6 2 2 0 1 1 0 1 5 ## all.sum ## 1 6 ## 2 5 ## 3 5 ## 4 5 ## 5 5 ## 6 5 Você pode ter uma lista de genes envolvidos em um processo biológico comum. É interessante verificar se alguns, ou todos, desses genes são direcionados pelo(s) mesmo(s) miRNA(s). example4 &lt;- get_multimir(org = &#39;hsa&#39;, target = c(&#39;AKT2&#39;, &#39;CERS6&#39;, &#39;S1PR3&#39;, &#39;SULF2&#39;), table = &#39;predicted&#39;, summary = TRUE, predicted.cutoff.type = &#39;n&#39;, predicted.cutoff = 500000) ## Number predicted cutoff (predicted.cutoff) 500000 is larger than the total number of records in table pictar. All records will be queried. ## Number predicted cutoff (predicted.cutoff) 500000 is larger than the total number of records in table targetscan. All records will be queried. ## Searching diana_microt ... ## Searching elmmo ... ## Searching microcosm ... ## Searching miranda ... ## Searching mirdb ... ## Searching pictar ... ## Searching pita ... ## Searching targetscan ... example4.counts &lt;- addmargins(table(example4@summary[, 2:3])) example4.counts &lt;- example4.counts[-nrow(example4.counts), ] example4.counts &lt;- example4.counts[order(example4.counts[, 5], decreasing = TRUE), ] head(example4.counts) ## target_symbol ## mature_mirna_id AKT2 CERS6 S1PR3 SULF2 Sum ## hsa-miR-129-5p 0 1 2 1 4 ## hsa-miR-330-3p 0 1 2 1 4 ## hsa-miR-144-3p 0 1 2 0 3 ## hsa-miR-3180-5p 0 1 2 0 3 ## hsa-miR-325-3p 1 1 0 1 3 ## hsa-miR-34a-5p 0 1 2 0 3 "],["dados-não-estruturados.html", "Capítulo 10 Dados não estruturados 10.1 Texto 10.2 Imagens 10.3 Áudio", " Capítulo 10 Dados não estruturados Muitos dados estão apresentados de forma não estruturada, como por exemplo textos, imagens, vídeos e sons. No entanto, também podemos analisar esse tipo de dados. Por exemplo, um texto pode ser utilizado em um processo de mineração de dados. Nesse capítulo veremos com trabalhar com textos, imagens e sons no R. 10.1 Texto Você pode usar qualquer texto, salve como um arquivo txt. Vamos carregar um arquivo de texto. Para isso usaremos o pacote tm: library(tm) library(dplyr) texto&lt;-Corpus(DirSource(getwd(),pattern = &quot;texto.txt&quot;)) Mas o texto carregado não está em um formato que possa ser analisado, então usamos a função VectorSource que interpreta cada elemento do vetor x como um documento. docs &lt;- Corpus(VectorSource(texto)) Mas um texto tem muitos elementos que não são tão relevantes para uma análise, como pontuação, espaços, stop words e números. Podemos resolver isso com as seguintes funções: docs &lt;- docs %&gt;% tm_map(removeNumbers) %&gt;% tm_map(removePunctuation) %&gt;% tm_map(stripWhitespace) docs &lt;- tm_map(docs, content_transformer(tolower)) docs &lt;- tm_map(docs, removeWords, stopwords(&quot;english&quot;)) Agora transformamos em uma matriz: dtm &lt;- TermDocumentMatrix(docs) matrix &lt;- as.matrix(dtm) head(matrix) ## Docs ## Terms 1 2 3 ## able 1 0 0 ## accumulated 2 0 0 ## accumulation 1 0 0 ## acquired 1 0 0 ## act 7 0 0 ## acted 1 0 0 Podemos criar um objeto com as palavras e organizamos as palavras por frequência: words &lt;- sort(rowSums(matrix),decreasing=TRUE) df &lt;- data.frame(word = names(words),freq=words) head(df) ## word freq ## selection selection 24 ## natural natural 20 ## can can 15 ## life life 13 ## nature nature 13 ## far far 11 Para procurar os termos mais frequentes usamos a função findFreqTerms, por exemplo, procurar os termos que ocorrem pelo menos 10 vezes: inspect(dtm) ## &lt;&lt;TermDocumentMatrix (terms: 628, documents: 3)&gt;&gt; ## Non-/sparse entries: 628/1256 ## Sparsity : 67% ## Maximal term length: 14 ## Weighting : term frequency (tf) ## Sample : ## Docs ## Terms 1 2 3 ## can 15 0 0 ## far 11 0 0 ## life 13 0 0 ## may 11 0 0 ## natural 20 0 0 ## nature 13 0 0 ## selection 24 0 0 ## structure 11 0 0 ## variations 9 0 0 ## will 10 0 0 findFreqTerms(dtm, 10) ## [1] &quot;can&quot; &quot;far&quot; &quot;life&quot; &quot;may&quot; &quot;natural&quot; &quot;nature&quot; ## [7] &quot;selection&quot; &quot;structure&quot; &quot;will&quot; Uma das coisas que é possível fazer com esse objeto é uma nuvemn de palavras, para isso vamos usar o pacote wordcloud2: library(wordcloud2) wordcloud2(data=df, size=1.6, color=&#39;random-dark&#39;) 10.1.1 Análise de sentimentos A Análise de Sentimentos é o estudo computacional de opiniões, sentimentos e emoções expressas em um texto. Na educação, ela é empregada como método para a obtenção do “feedback” dos alunos ou avaliação de professores. Os professores as vezes têm que lidar com grandes quantidades de mídia textual, o que é trabalhoso e demanda tempo. Nesse cenário, a utilização de ferramentas computacionais que os auxiliem na tarefa de analisar textos é muito atrativa. A ideia é que se possa identificar a tendência geral de uma turma em relação ao tema em discussão, sem a necessidade de ler todos os textos, que podem ser volumosos. Como exemplo, vamos o mesmo texto, mas agora usaremos o pacote pdftools para ler um arquivo pdf. library(pdftools) texto2&lt;-pdf_text(&quot;texto.pdf&quot;) E agora usaremos o pacote syuzhet para fazer a análise de sentimentos. library(syuzhet) library(RColorBrewer) sentimentos &lt;- get_nrc_sentiment(texto2, lang=&quot;english&quot;, lowercase = T) E plotamos o resultado em um gráfico: barplot( colSums(prop.table(sentimentos[, 1:8])), space = 0.2, horiz = FALSE, las = 1, cex.names = 0.7, col = brewer.pal(n = 8, name = &quot;Set3&quot;), xlab=NULL, ylab = NULL) Também podemos resumir em sentimentos positivos e negativos: barplot( colSums(prop.table(sentimentos[, 9:10])), space = 0.2, horiz = FALSE, las = 1, cex.names = 0.7, col = c(&quot;tomato&quot;,&quot;skyblue3&quot;), xlab=NULL, ylab = NULL) 10.2 Imagens As imagens são outro tipo de dado não estruturado e também podem ser carregadas e editadas. Como exemplo veremos o pacote magick. library(magick) foto&lt;-image_read(&#39;dados/foto.jpg&#39;) foto Também podemos salvar em diferentes formatos: image_write(foto, path = &quot;dados/foto.png&quot;, format = &quot;png&quot;) 10.2.1 Edição de imagens Podemos cortar a imagem: 500px por350px começando na esquerda em +1550px: image_crop(foto, &quot;500x350+1550&quot;) Para redimensionar proporcionalmente à largura: image_scale(foto, &quot;500&quot;) Para redimensionar proporcionalmente à altura: image_scale(foto, &quot;x200&quot;) Adicionar uma borda: image_border(foto, &quot;red&quot;, &quot;20x10&quot;) Vamos redimensionar a imagem para fazer outras alterações foto2&lt;-image_scale(foto, &quot;400&quot;) foto2 Rotações de imagem: image_rotate(foto2, 45) image_flip(foto2) image_flop(foto2) Brilho, saturação e matiz: image_modulate(foto2, brightness = 80, saturation = 120, hue = 90) Pintar a mesa de laranja: image_fill(foto2, &quot;orange&quot;, point = &quot;+100+200&quot;, fuzz = 20) Outros efeitos: image_blur(foto2, 10, 5) image_charcoal(foto2) image_oilpaint(foto2) image_negate(foto2) Adicionando texto: image_annotate(foto2, &quot;Laboratório&quot;, size = 70, gravity = &quot;southwest&quot;, color = &quot;green&quot;) Personalizando o texto; image_annotate(foto2, &quot;UFPR&quot;, size = 30, color = &quot;red&quot;, boxcolor = &quot;pink&quot;, degrees = -45, location = &quot;+150+100&quot;,font = &#39;Times&#39;) Usando pipes Cada uma das funções de transformação de imagem retorna uma cópia modificada da imagem original. Não afeta a imagem original. foto2 %&gt;% image_rotate(270) %&gt;% image_background(&quot;blue&quot;, flatten = TRUE) %&gt;% image_border(&quot;red&quot;, &quot;10x10&quot;) %&gt;% image_annotate(&quot;Lab&quot;, color = &quot;blue&quot;, size = 50) Vamos carregar outra imagem: logo&lt;-image_read(&#39;dados/R.PNG&#39;) logo E colocar as duas imagens em um vetor: img &lt;- c(foto2, logo) Um mosaico imprime imagens umas sobre as outras, expandindo a tela de saída de forma que tudo se encaixe: image_mosaic(img) O achatamento combina as camadas em uma única imagem que tem o tamanho da primeira imagem. O nivelamento e o mosaico permitem especificar operadores compostos alternativos: image_flatten(img, &#39;Add&#39;) image_flatten(img, &#39;Modulate&#39;) image_flatten(img, &#39;Minus&#39;) Combinando imagens Anexar significa simplesmente colocar os quadros um ao lado do outro: image_append(image_scale(img, &quot;x200&quot;)) image_append(image_scale(img, &quot;100&quot;), stack = TRUE) A composição permite combinar duas imagens em uma posição específica: logo2&lt;-image_scale(image_rotate(image_background(logo, &quot;none&quot;), 300), &quot;x200&quot;) image_composite(image_scale(foto2, &quot;x400&quot;), logo2, offset = &quot;+180+100&quot;) Animação Em vez de tratar os elementos vetoriais como camadas, também podemos transformá-los em quadros em uma animação. image_animate(image_scale(img, &quot;300x300&quot;), fps = 1, dispose = &quot;previous&quot;) Morphing cria uma sequência de n imagens que transformam gradualmente uma imagem em outra. Faz animações newlogo &lt;- image_scale(image_read(&quot;https://jeroen.github.io/images/Rlogo.png&quot;)) oldlogo &lt;- image_scale(image_read(&quot;https://jeroen.github.io/images/Rlogo-old.png&quot;)) image_resize(c(oldlogo, newlogo), &#39;200x150!&#39;) %&gt;% image_background(&#39;white&#39;) %&gt;% image_morph() %&gt;% image_animate(optimize = TRUE) 10.3 Áudio Assim como as imagens, também podemos trabalhar com arquivos de áudio. Para isso, utilizaremos o pacote tuneR. Vamos usar um arquivo de áudio em mp3. library(tuneR) bird &lt;- readMP3(&quot;dados/bird.mp3&quot;) bird ## ## Wave Object ## Number of Samples: 95616 ## Duration (seconds): 2.17 ## Samplingrate (Hertz): 44100 ## Channels (Mono/Stereo): Stereo ## PCM (integer format): TRUE ## Bit (8/16/24/32/64): 16 plot(bird) Usando: play(bird) será acionado um player de áudio para tocar o áudio. Pegaremos apenas um canal para extrair algumas informações do áudio. wobjm &lt;- mono(bird, &quot;left&quot;) WspecObject &lt;- periodogram(wobjm, normalize = TRUE, width = 1024, overlap = 512) Vejamos o primeiro periodograma: plot(WspecObject, xlim = c(0, 3000), which = 1) Ou o espectrograma: image(WspecObject, ylim = c(0, 500)) Calculando a frequência fundamental ff &lt;- FF(WspecObject) print(ff) ## [1] 64.59961 NA NA 157.61370 190.49718 NA ## [7] 122.38931 NA NA 68.65275 1307.25253 1304.91011 ## [13] 186.36882 NA NA 208.51484 NA 239.47304 ## [19] 1316.87812 1307.09008 203.61197 NA NA NA ## [25] 224.89103 1229.82436 1191.25743 1225.72103 115.94173 NA ## [31] 280.35222 136.92399 113.80207 1144.64054 1175.98917 450.59224 ## [37] 228.69309 NA NA 247.74156 1135.16935 1138.56091 ## [43] 1181.17227 111.98844 225.52343 193.87516 NA 141.20795 ## [49] 1223.99605 1189.99512 239.65834 158.96104 162.50840 136.96878 ## [55] 195.89302 1179.23405 1176.32140 279.89437 142.01919 234.51471 ## [61] 184.57174 285.11695 1182.03568 1182.27814 240.39591 188.66432 ## [67] 201.72665 201.73638 1145.25713 1171.13817 2347.22572 137.95489 ## [73] 310.06133 239.62800 220.72491 1147.34294 1149.32670 1271.95231 ## [79] 116.00928 NA 178.83420 191.57976 1190.65734 2388.42507 ## [85] 191.24564 199.89378 236.02492 285.11982 1183.38516 1189.22560 ## [91] 156.13566 250.04596 189.38153 107.84409 1179.68209 1177.59186 ## [97] 1962.26711 223.28651 210.78742 224.84481 139.18888 1174.04464 ## [103] 1178.07041 201.16565 192.20782 124.65268 179.78313 1185.21392 ## [109] 1183.06218 189.63599 187.53263 146.04791 116.55402 315.08823 ## [115] 2432.35358 2431.15224 169.64383 161.82987 234.15430 1143.98102 ## [121] 2333.10267 1181.81971 1106.25765 151.89479 139.98791 275.27740 ## [127] 497.53243 1229.88256 2046.93927 195.21948 281.09972 232.03905 ## [133] 199.26075 2393.29052 2400.57146 322.29840 204.85652 194.56689 ## [139] 269.21640 363.42894 2278.99300 2296.81342 239.29813 318.95594 ## [145] 196.19900 159.64041 1224.43889 1225.66359 2432.01938 279.17197 ## [151] 238.88824 271.84562 311.88075 2044.02861 1970.36983 1199.44922 ## [157] 2398.11124 284.57293 283.13241 319.35321 157.07776 325.65761 ## [163] 1787.00889 586.06028 196.28648 324.72040 335.16499 278.96700 ## [169] 283.27520 NA 205.36409 144.30646 147.86967 NA ## [175] 200.75462 193.42870 196.70002 223.36453 209.97048 209.47188 ## [181] NA NA 64.59961 64.59961 64.59961 64.59961 Derivar nota de FF dado diapasão A=440 notes &lt;- noteFromFF(ff, 440) Suavizar as notas: library(pastecs) snotes &lt;- smoother(notes) O resultado deve ser 0 para o A do diapasão e -12 (12 meios-tons abaixo) para A print(snotes) ## [1] 492.50 492.50 492.50 255.75 19.00 19.00 19.00 19.00 19.00 19.00 ## [11] 19.00 19.00 19.00 19.00 19.00 19.00 19.00 19.00 19.00 19.00 ## [21] 19.00 19.00 19.00 18.00 18.00 18.00 18.00 17.00 17.00 17.00 ## [31] 0.00 0.00 0.00 0.00 0.00 0.00 16.00 16.00 16.00 16.00 ## [41] 16.00 16.00 16.00 16.00 16.00 -10.00 -11.00 -12.00 -12.00 -12.00 ## [51] -12.00 -14.00 -14.00 -14.00 -14.00 -11.00 -11.00 -11.00 -11.00 -11.00 ## [61] -10.00 -10.00 -8.00 -10.00 -10.00 -10.00 -10.00 -10.00 -10.00 -8.00 ## [71] -6.00 -6.00 -6.00 -6.00 -6.00 -6.00 17.00 -6.00 -6.00 -6.00 ## [81] -11.00 -11.00 -8.00 -10.00 -11.00 -11.00 -11.00 -10.00 -10.00 -10.00 ## [91] -10.00 -10.00 -11.00 -11.00 -10.00 -12.00 -12.00 -12.00 -12.00 -12.00 ## [101] -12.00 -13.00 -14.00 -14.00 -14.00 -14.00 -14.00 -14.00 -15.00 -15.00 ## [111] -15.00 -15.00 -15.00 -15.00 -11.00 -6.00 -11.00 -8.00 -6.00 2.00 ## [121] 16.00 16.00 2.00 2.00 -8.00 -8.00 2.00 -5.00 -8.00 -8.00 ## [131] -8.00 -8.00 -8.00 -8.00 -5.00 -6.00 -8.00 -9.00 -6.00 -6.00 ## [141] -5.00 -6.00 -6.00 -6.00 -8.00 -6.00 -6.00 -6.00 -6.00 -6.00 ## [151] -6.00 -6.00 -6.00 -6.00 -5.00 -5.00 -6.00 -6.00 -6.00 -5.00 ## [161] -5.00 -5.00 -5.00 -5.00 -5.00 -5.00 -5.00 -8.00 -8.00 -8.00 ## [171] -8.00 -13.00 -13.00 -13.00 -13.00 -13.00 -13.00 -13.00 -13.00 -13.00 ## [181] -13.00 -13.00 -18.00 -23.00 -28.00 -33.00 Plotar a melodia e energia do som: melodyplot(WspecObject, snotes) Aplique alguma quantização (em 8 partes) e um gráfico, 4 partes por barra: qnotes &lt;- quantize(snotes, WspecObject@energy, parts = 8) quantplot(qnotes, expected = rep(c(0, -12), each = 4), bars = 2) E preparando o objeto para o LilyPond. LilyPond é um programa de gravação de música, dedicado a produzir partituras de alta qualidade possíveis (http://lilypond.org/). qlily &lt;- quantMerge(snotes, 4, 4, 2) qlily ## note duration punctuation slur ## 1 19 4 FALSE FALSE ## 2 16 4 FALSE FALSE ## 3 -10 4 FALSE FALSE ## 4 -6 4 FALSE FALSE ## 5 -15 4 FALSE FALSE ## 6 -8 4 FALSE FALSE ## 7 -6 4 FALSE FALSE ## 8 -13 4 FALSE FALSE "],["pesquisa-bibliográfica-e-bibliometria.html", "Capítulo 11 Pesquisa bibliográfica e Bibliometria 11.1 Pesquisa bibliográfica 11.2 PubMed 11.3 Bibliometria", " Capítulo 11 Pesquisa bibliográfica e Bibliometria Uma etapa muito importante em qualquer pesquisa científica é fazer o levantamento bibliográfico. Temos diversas bases de dados nas quais podemos fazer essa busca, sendo que o PubMed é uma das principais. O número de publicações acadêmicas está aumentando em ritmo acelerado e está se tornando cada vez mais inviável manter-se atualizado com tudo o que está sendo publicado. Os pesquisadores usam diferentes abordagens qualitativas e quantitativas de revisão de literatura para entender e organizar descobertas anteriores. Entre eles, a bibliometria tem o potencial de introduzir um processo de revisão sistemática, transparente e reprodutível baseado na medição estatística da ciência, dos cientistas ou da atividade científica. 11.1 Pesquisa bibliográfica Antes de fazer uma análise bibliométrica, é preciso fazer uma pesquisa bibliográfica. Para isso temos que estabelecer um pergunta a ser respondida. Com base no que queremos saber, definimos os descritores com os quais montaremos nosso termo de nossa busca. Para auxiliar na escolha dos descritores, podemos usar o DeCS/MeSH (https://decs.bvsalud.org/). Aqui poderemos ver, entre outras coisas: - a grafia em diferentes idiomas - os sinônimos 11.1.1 Termos da busca Uma vez definidos os descritores, usamos os operadores boleanos AND, OR, NOT para compor o termo de busca. Exemplos: - butyrylcholinesterase OR pseudocholinesterase - butyrylcholinesterase AND acetylcholinesterase - butyrylcholinesterase NOT alzheimer - ((butyrylcholinesterase OR pseudocholinesterase) AND acetylcholinesterase) NOT alzheimer Uma vez montado o termo de busca, podemos usá-lo em diferentes bases de dados para fazer nossa pesquisa bibliográfica. 11.1.2 Bases de dados Temos diversas bases de dados. No Brasil temos o Portal de Periódicos CAPES, ao qual temos acesso completo apenas a partir das Universidades. Portal de Periódicos CAPES (https://www-periodicos-capes-gov-br.ezl.periodicos.capes.gov.br/index.php?) Também a partir do Portal de Periódicos CAPES, temos acesso a outras bases como a Web of Science e Scopus. Além dessas, temos várias outras, como: PubMed (https://pubmed.ncbi.nlm.nih.gov/) Dimensions (https://app.dimensions.ai/discover/publication ) 11.2 PubMed No caso do PubMed, é possível fazer a busca diretamente pelo R, utilizando o pacote pubmedR. Podem ver dicas de utilização do pacote em: https://cran.r-project.org/web/packages/pubmedR/vignettes/A_Brief_Example.html Vamos ver um exemplo de utilização, em query montamos o termo de busca e colocamos alguns filtros. Com a função pmQueryTotalCount podemos ver quantos registros a busca retorna: library(pubmedR) query &lt;- &quot;PON1[Title/Abstract] AND english[LA] AND Journal Article[PT] AND 2018:2023[DP]&quot; res &lt;- pmQueryTotalCount(query = query, api_key = NULL) res$total_count ## [1] 909 Com a função pmApiRequest vamos fazer o download dos dados e com a função pmApi2df transformamos em um dataframe: D &lt;- pmApiRequest(query = query, limit = 200, api_key = NULL) ## Documents 200 of 200 df &lt;- pmApi2df(D) ## ================================================================================ São baixados os metadados de cada referência, como título, autores, resumo, revista, ano, etc. names(df) ## [1] &quot;AU&quot; &quot;AF&quot; &quot;TI&quot; &quot;SO&quot; &quot;SO_CO&quot; &quot;LA&quot; ## [7] &quot;DT&quot; &quot;DE&quot; &quot;ID&quot; &quot;MESH&quot; &quot;AB&quot; &quot;C1&quot; ## [13] &quot;CR&quot; &quot;TC&quot; &quot;SN&quot; &quot;J9&quot; &quot;JI&quot; &quot;PY&quot; ## [19] &quot;PY_IS&quot; &quot;VL&quot; &quot;DI&quot; &quot;PG&quot; &quot;GRANT_ID&quot; &quot;GRANT_ORG&quot; ## [25] &quot;UT&quot; &quot;PMID&quot; &quot;DB&quot; &quot;AU_UN&quot; &quot;AU_CO&quot; &quot;AU1_CO&quot; df$TI[1] ## [1] &quot;THE EFFECT OF ROYAL JELLY ON TELOMERE LENGTH AND SOME BIOCHEMICAL PARAMETERS IN WISTAR ALBINO RATS WITH LIVER DAMAGE CAUSED BY CARBON TETRACHLORIDE.&quot; Esses dados, em sua maioria, são caracteres, mas também podemos trabalhar com dados não estruturados no R. O pacote tm tem funções para podermos trabalhar com texto. Vamos pegar os títulos dos artigos: library(tm) library(dplyr) texto &lt;- iconv(df$TI, to = &quot;UTF-8&quot;) docs &lt;- Corpus(VectorSource(texto)) docs &lt;- docs %&gt;% tm_map(removePunctuation) %&gt;% tm_map(stripWhitespace) docs &lt;- tm_map(docs, content_transformer(tolower)) docs &lt;- tm_map(docs, removeWords, stopwords(&quot;english&quot;)) A seguir criamos um dataframe com as palavras em ordem decrescente de frequência: dtm &lt;- TermDocumentMatrix(docs) matrix &lt;- as.matrix(dtm) words &lt;- sort(rowSums(matrix),decreasing=TRUE) df2 &lt;- data.frame(word = names(words),freq=words) head(df2) ## word freq ## paraoxonase paraoxonase 44 ## activity activity 32 ## patients patients 31 ## disease disease 28 ## paraoxonase1 paraoxonase1 24 ## pon1 pon1 22 E com esse dataframe podemos fazer uma nuvem de palavras: library(wordcloud2) wordcloud2(data=df2, size=1.6, color=&#39;random-dark&#39;) 11.3 Bibliometria Para fazer uma análise bibliométrica usamos o pacote bibliometrix O manual pode ser acessado em https://www.bibliometrix.org/vignettes/Introduction_to_bibliometrix.html (Aria and Cuccurullo 2017) Você pode fazer sua busca no Web of Science, depois clique em exportar, arquivo de texto sem formatação, escolha a opção de quais quer salvar e selecione a opção registro completo, referências citadas e clique em exportar. Note que com essa opção é possível salvar 500 referências de cada vez, então se tiver mais de 500 referências, você terá vários arquivos, mas poderá importá-los de uma só vez no R. Para fazer a bibliometria usaremos dados baixados, em formato texto, do Web of Science. Para fazer a bibliometria, podemos usar dados de várias bases de dados, mas a Web of Science é a que oferece o maior número de metadados, permitindo utilizar todas as opções de análise. library(bibliometrix) ## Warning: package &#39;bibliometrix&#39; was built under R version 4.3.1 ## Please note that our software is open source and available for use, distributed under the MIT license. ## When it is used in a publication, we ask that authors properly cite the following reference: ## ## Aria, M. &amp; Cuccurullo, C. (2017) bibliometrix: An R-tool for comprehensive science mapping analysis, ## Journal of Informetrics, 11(4), pp 959-975, Elsevier. ## ## Failure to properly cite the software is considered a violation of the license. ## ## For information and bug reports: ## - Take a look at https://www.bibliometrix.org ## - Send an email to info@bibliometrix.org ## - Write a post on https://github.com/massimoaria/bibliometrix/issues ## ## Help us to keep Bibliometrix and Biblioshiny free to download and use by contributing with a small donation to support our research team (https://bibliometrix.org/donate.html) ## ## ## To start with the Biblioshiny app, please digit: ## biblioshiny() ## ## Attaching package: &#39;bibliometrix&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## logo ## The following object is masked from &#39;package:magick&#39;: ## ## logo ## The following object is masked from &#39;package:IRanges&#39;: ## ## trim ## The following object is masked from &#39;package:gdata&#39;: ## ## trim file1 &lt;- c(&quot;dados/wos.txt&quot;) M1 &lt;- convert2df(file = file1, dbsource = &quot;wos&quot;, format = &quot;plaintext&quot;) ## ## Converting your wos collection into a bibliographic dataframe ## ## Done! ## ## ## Generating affiliation field tag AU_UN from C1: Done! Podemos ver um resumo da análise: results &lt;- biblioAnalysis(M1) summary(results) ## ## ## MAIN INFORMATION ABOUT DATA ## ## Timespan 2013 : 2023 ## Sources (Journals, Books, etc) 261 ## Documents 500 ## Annual Growth Rate % -18.6 ## Document Average Age 5.31 ## Average citations per doc 16.2 ## Average citations per year per doc 2.425 ## References 14641 ## ## DOCUMENT TYPES ## article 452 ## article; book chapter 1 ## article; early access 5 ## article; proceedings paper 21 ## meeting abstract 3 ## proceedings paper 1 ## review 17 ## ## DOCUMENT CONTENTS ## Keywords Plus (ID) 1476 ## Author&#39;s Keywords (DE) 1260 ## ## AUTHORS ## Authors 2331 ## Author Appearances 3225 ## Authors of single-authored docs 12 ## ## AUTHORS COLLABORATION ## Single-authored docs 19 ## Documents per Author 0.215 ## Co-Authors per Doc 6.45 ## International co-authorships % 29 ## ## ## Annual Scientific Production ## ## Year Articles ## 2013 47 ## 2014 41 ## 2015 38 ## 2016 51 ## 2017 52 ## 2018 54 ## 2019 66 ## 2020 44 ## 2021 52 ## 2022 44 ## 2023 6 ## ## Annual Percentage Growth Rate -18.6 ## ## ## Most Productive Authors ## ## Authors Articles Authors Articles Fractionalized ## 1 GULCIN I 38 POHANKA M 8.17 ## 2 TASLIMI P 32 GULCIN I 6.58 ## 3 LOCKRIDGE O 21 TASLIMI P 5.23 ## 4 MASSON P 19 LOCKRIDGE O 4.52 ## 5 KUCA K 14 TURKAN F 3.43 ## 6 MUSILEK K 14 MASSON P 3.10 ## 7 SCHOPFER LM 14 SCHOPFER LM 3.08 ## 8 STEPANKOVA S 13 SAXENA A 2.64 ## 9 JUN D 11 STEPANKOVA S 2.06 ## 10 KOVARIK Z 11 KUCA K 2.02 ## ## ## Top manuscripts per citations ## ## Paper DOI TC TCperYear NTC ## 1 GULCIN I, 2016, J ENZYM INHIB MED CH 10.3109/14756366.2015.1135914 144 18.0 4.81 ## 2 TURKAN F, 2019, BIOORG CHEM 10.1016/j.bioorg.2019.02.013 135 27.0 8.56 ## 3 AKSU K, 2016, ARCH PHARM 10.1002/ardp.201600183 119 14.9 3.97 ## 4 OZTASKIN N, 2017, BIOORG CHEM 10.1016/j.bioorg.2017.07.010 117 16.7 5.04 ## 5 BAYRAK C, 2017, BIOORG CHEM 10.1016/j.bioorg.2017.03.001 114 16.3 4.91 ## 6 ERDEMIR F, 2018, J MOL STRUCT 10.1016/j.molstruc.2017.11.079 113 18.8 6.29 ## 7 GARIBOV E, 2016, J ENZYM INHIB MED CH 10.1080/14756366.2016.1198901 112 14.0 3.74 ## 8 GULCIN I, 2016, J ENZYM INHIB MED CH-a 10.3109/14756366.2015.1094470 110 13.8 3.67 ## 9 OZGUN DO, 2016, J ENZYM INHIB MED CH 10.3109/14756366.2016.1149479 109 13.6 3.64 ## 10 OZBEY F, 2016, J ENZYM INHIB MED CH 10.1080/14756366.2016.1189422 107 13.4 3.57 ## ## ## Corresponding Author&#39;s Countries ## ## Country Articles Freq SCP MCP MCP_Ratio ## 1 TURKEY 71 0.1429 54 17 0.239 ## 2 USA 68 0.1368 46 22 0.324 ## 3 CZECH REPUBLIC 42 0.0845 32 10 0.238 ## 4 CHINA 41 0.0825 35 6 0.146 ## 5 BRAZIL 32 0.0644 24 8 0.250 ## 6 PAKISTAN 28 0.0563 16 12 0.429 ## 7 RUSSIA 26 0.0523 16 10 0.385 ## 8 INDIA 20 0.0402 17 3 0.150 ## 9 GERMANY 19 0.0382 15 4 0.211 ## 10 KOREA 15 0.0302 12 3 0.200 ## ## ## SCP: Single Country Publications ## ## MCP: Multiple Country Publications ## ## ## Total Citations per Country ## ## Country Total Citations Average Article Citations ## 1 TURKEY 2581 36.35 ## 2 USA 980 14.41 ## 3 ITALY 477 34.07 ## 4 CZECH REPUBLIC 470 11.19 ## 5 CHINA 404 9.85 ## 6 BRAZIL 319 9.97 ## 7 PAKISTAN 318 11.36 ## 8 INDIA 273 13.65 ## 9 POLAND 265 18.93 ## 10 KOREA 229 15.27 ## ## ## Most Relevant Sources ## ## Sources Articles ## 1 CHEMICO-BIOLOGICAL INTERACTIONS 31 ## 2 MOLECULES 22 ## 3 JOURNAL OF ENZYME INHIBITION AND MEDICINAL CHEMISTRY 18 ## 4 BIOORGANIC CHEMISTRY 17 ## 5 JOURNAL OF BIOCHEMICAL AND MOLECULAR TOXICOLOGY 11 ## 6 EUROPEAN JOURNAL OF MEDICINAL CHEMISTRY 10 ## 7 ARCHIV DER PHARMAZIE 9 ## 8 BIOORGANIC &amp; MEDICINAL CHEMISTRY 7 ## 9 ARCHIVES OF TOXICOLOGY 6 ## 10 JOURNAL OF MOLECULAR STRUCTURE 6 ## ## ## Most Relevant Keywords ## ## Author Keywords (DE) Articles Keywords-Plus (ID) Articles ## 1 BUTYRYLCHOLINESTERASE 296 ACETYLCHOLINESTERASE 152 ## 2 ACETYLCHOLINESTERASE 262 BUTYRYLCHOLINESTERASE 88 ## 3 MOLECULAR DOCKING 46 ALZHEIMERS-DISEASE 86 ## 4 CARBONIC ANHYDRASE 34 DERIVATIVES 65 ## 5 ENZYME INHIBITION 32 CHOLINESTERASE 42 ## 6 ORGANOPHOSPHATE 17 DESIGN 42 ## 7 MOLECULAR MODELING 13 CHOLINESTERASES 37 ## 8 ANTIOXIDANT 12 INHIBITION 35 ## 9 ANTIOXIDANT ACTIVITY 12 IN-VITRO 34 ## 10 BIOSCAVENGER 12 BIOLOGICAL EVALUATION 33 Podemos ver os principais autores sobre o tema e sua produção ao longo do tempo topAU &lt;- authorProdOverTime(M1, k = 10, graph = TRUE) topAU ## $dfAU ## Author year freq TC TCpY ## 1 GULCIN I 2016 7 787 98.3750000 ## 2 GULCIN I 2017 10 732 104.5714286 ## 3 GULCIN I 2018 9 544 90.6666667 ## 4 GULCIN I 2019 6 362 72.4000000 ## 5 GULCIN I 2020 3 31 7.7500000 ## 6 GULCIN I 2021 1 29 9.6666667 ## 7 GULCIN I 2022 1 0 0.0000000 ## 8 JUN D 2013 2 48 4.3636364 ## 9 JUN D 2014 1 9 0.9000000 ## 10 JUN D 2017 2 36 5.1428571 ## 11 JUN D 2018 1 6 1.0000000 ## 12 JUN D 2019 2 2 0.4000000 ## 13 JUN D 2020 1 14 3.5000000 ## 14 JUN D 2021 1 2 0.6666667 ## 15 JUN D 2022 1 0 0.0000000 ## 16 KOVARIK Z 2013 2 77 7.0000000 ## 17 KOVARIK Z 2016 2 45 5.6250000 ## 18 KOVARIK Z 2017 2 34 4.8571429 ## 19 KOVARIK Z 2018 1 21 3.5000000 ## 20 KOVARIK Z 2019 1 21 4.2000000 ## 21 KOVARIK Z 2020 2 27 6.7500000 ## 22 KOVARIK Z 2021 1 9 3.0000000 ## 23 KUCA K 2013 3 62 5.6363636 ## 24 KUCA K 2015 2 27 3.0000000 ## 25 KUCA K 2017 2 36 5.1428571 ## 26 KUCA K 2018 1 6 1.0000000 ## 27 KUCA K 2019 5 38 7.6000000 ## 28 KUCA K 2020 1 14 3.5000000 ## 29 LOCKRIDGE O 2013 1 13 1.1818182 ## 30 LOCKRIDGE O 2014 2 43 4.3000000 ## 31 LOCKRIDGE O 2015 3 89 9.8888889 ## 32 LOCKRIDGE O 2016 5 95 11.8750000 ## 33 LOCKRIDGE O 2017 3 41 5.8571429 ## 34 LOCKRIDGE O 2018 4 30 5.0000000 ## 35 LOCKRIDGE O 2019 1 5 1.0000000 ## 36 LOCKRIDGE O 2020 1 1 0.2500000 ## 37 LOCKRIDGE O 2022 1 2 1.0000000 ## 38 MASSON P 2013 1 17 1.5454545 ## 39 MASSON P 2014 2 28 2.8000000 ## 40 MASSON P 2015 1 17 1.8888889 ## 41 MASSON P 2016 3 73 9.1250000 ## 42 MASSON P 2017 2 29 4.1428571 ## 43 MASSON P 2018 2 5 0.8333333 ## 44 MASSON P 2019 4 18 3.6000000 ## 45 MASSON P 2020 2 12 3.0000000 ## 46 MASSON P 2021 1 1 0.3333333 ## 47 MASSON P 2022 1 1 0.5000000 ## 48 MUSILEK K 2013 1 19 1.7272727 ## 49 MUSILEK K 2015 2 27 3.0000000 ## 50 MUSILEK K 2018 1 6 1.0000000 ## 51 MUSILEK K 2019 5 27 5.4000000 ## 52 MUSILEK K 2020 1 14 3.5000000 ## 53 MUSILEK K 2021 4 13 4.3333333 ## 54 SCHOPFER LM 2013 1 13 1.1818182 ## 55 SCHOPFER LM 2014 1 20 2.0000000 ## 56 SCHOPFER LM 2015 1 40 4.4444444 ## 57 SCHOPFER LM 2016 2 28 3.5000000 ## 58 SCHOPFER LM 2017 3 41 5.8571429 ## 59 SCHOPFER LM 2018 3 28 4.6666667 ## 60 SCHOPFER LM 2019 1 5 1.0000000 ## 61 SCHOPFER LM 2020 1 1 0.2500000 ## 62 SCHOPFER LM 2022 1 2 1.0000000 ## 63 STEPANKOVA S 2013 1 37 3.3636364 ## 64 STEPANKOVA S 2014 2 20 2.0000000 ## 65 STEPANKOVA S 2015 1 19 2.1111111 ## 66 STEPANKOVA S 2016 2 33 4.1250000 ## 67 STEPANKOVA S 2018 1 12 2.0000000 ## 68 STEPANKOVA S 2020 3 13 3.2500000 ## 69 STEPANKOVA S 2021 2 11 3.6666667 ## 70 STEPANKOVA S 2022 1 1 0.5000000 ## 71 TASLIMI P 2016 5 533 66.6250000 ## 72 TASLIMI P 2017 8 636 90.8571429 ## 73 TASLIMI P 2018 9 544 90.6666667 ## 74 TASLIMI P 2019 5 353 70.6000000 ## 75 TASLIMI P 2021 1 29 9.6666667 ## 76 TASLIMI P 2022 4 5 2.5000000 ## ## $dfPapersAU ## # A tibble: 186 × 7 ## Author year TI SO DOI TC TCpY ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GULCIN I 2022 EVALUATION OF ANTICHOLINERGIC, ANTIDIABETIC AND ANTIOXIDANT ACTIVITY OF ASTRA… KSU … 10.1… 0 0 ## 2 GULCIN I 2021 DETERMINATION OF ANTICANCER PROPERTIES AND INHIBITORY EFFECTS OF SOME METABOL… JOUR… 10.1… 29 9.67 ## 3 GULCIN I 2020 ANTICHOLINERGIC AND ANTIOXIDANT ACTIVITIES OF AVOCADO (FOLIUM PERSEAE) LEAVES… INTE… 10.1… 24 6 ## 4 GULCIN I 2020 SYNTHESIS AND PHARMACOLOGICAL EFFECTS OF NOVEL BENZENESULFONAMIDES CARRYING B… TURK… 10.3… 4 1 ## 5 GULCIN I 2020 SCREENING OF NON-ALKALOID ACETYLCHOLINESTERASE AND CARBONIC ANHYDRASE ISOENZY… JOUR… 10.1… 3 0.75 ## 6 GULCIN I 2019 THE IMPACTS OF SOME SEDATIVE DRUGS ON ALPHA -GLYCOSIDASE, ACETYLCHOLINESTERAS… LETT… 10.2… 18 3.6 ## 7 GULCIN I 2019 THE EFFECTS OF SOME ANTIBIOTICS FROM CEPHALOSPORIN GROUPS ON THE ACETYLCHOLIN… ARCH… 10.1… 47 9.4 ## 8 GULCIN I 2019 PHYTOCHEMICAL CONTENT, ANTIOXIDANT ACTIVITY, AND ENZYME INHIBITION EFFECT OF … JOUR… 10.1… 93 18.6 ## 9 GULCIN I 2019 SYNTHESIS, CHARACTERIZATION, CRYSTAL STRUCTURES, THEORETICAL CALCULATIONS AND… JOUR… 10.1… 60 12 ## 10 GULCIN I 2019 SAR EVALUATION OF DISUBSTITUTED TACRINE ANALOGUES AS PROMISING CHOLINESTERASE… INDI… 10.5… 9 1.8 ## # ℹ 176 more rows ## ## $graph Também podemos ver a co-ocorrência de palavras-chave: NetMatrix &lt;- biblioNetwork(M1, analysis = &quot;co-occurrences&quot;, network = &quot;keywords&quot;, sep = &quot;;&quot;) net=networkPlot(NetMatrix, normalize=&quot;association&quot;, weighted=T, n = 30, Title = &quot;Keyword Co-occurrences&quot;, type = &quot;fruchterman&quot;, size=T,edgesize = 5,labelsize=0.7) E estruturas conceituais usando as palavras-chave: CS &lt;- conceptualStructure(M1,field=&quot;ID&quot;, method=&quot;CA&quot;, minDegree=4, clust=5, stemming=FALSE, labelsize=10, documents=10) Toda a análise bibliométrica também pode ser feita utilizando shiny, para isso usamos a seguinte função: biblioshiny(), com a qual será aberta uma janela interativa, onde carregamos o arquivo e podemos fazer as análises e gerar os gráficos. Para maiores detalhes, consulte a documentação no site https://www.bibliometrix.org/ References "],["r-markdown.html", "Capítulo 12 R Markdown 12.1 Incluindo gráficos 12.2 Chunk: opções 12.3 Formatação", " Capítulo 12 R Markdown Este é um documento R Markdown. Markdown é uma sintaxe de formatação simples para criar documentos HTML, PDF e MS Word. Para obter mais detalhes sobre o uso do R Markdown, consulte http://rmarkdown.rstudio.com. Ao clicar no botão Knit, será gerado um documento que inclui tanto o conteúdo quanto a saída de qualquer fragmento de código R incorporado no documento. Você pode incorporar um pedaço de código R como este, no qual vamos carregar os pacotes, os dados, e gerar uma tabela com alguns informações estatísticas: library(openxlsx) library(nortest) library(gridExtra) dados&lt;-read.xlsx(&quot;dados/Data_Cortex_Nuclear.xlsx&quot;, sheet = 1, colNames = T) head(dados) ## MouseID DYRK1A_N ITSN1_N BDNF_N NR1_N NR2A_N pAKT_N pBRAF_N pCAMKII_N pCREB_N pELK_N pERK_N ## 1 309_1 0.5036439 0.7471932 0.4301753 2.816329 5.990152 0.2188300 0.1775655 2.373744 0.2322238 1.750936 0.6879062 ## 2 309_2 0.5146171 0.6890635 0.4117703 2.789514 5.685038 0.2116362 0.1728170 2.292150 0.2269721 1.596377 0.6950062 ## 3 309_3 0.5091831 0.7302468 0.4183088 2.687201 5.622059 0.2090109 0.1757222 2.283337 0.2302468 1.561316 0.6773484 ## 4 309_4 0.4421067 0.6170762 0.3586263 2.466947 4.979503 0.2228858 0.1764626 2.152301 0.2070042 1.595086 0.5832768 ## 5 309_5 0.4349402 0.6174298 0.3588022 2.365785 4.718679 0.2131059 0.1736270 2.134014 0.1921579 1.504230 0.5509601 ## 6 309_6 0.4475064 0.6281758 0.3673881 2.385939 4.807635 0.2185778 0.1762334 2.141282 0.1951875 1.442398 0.5663396 ## pJNK_N PKCA_N pMEK_N pNR1_N pNR2A_N pNR2B_N pPKCAB_N pRSK_N AKT_N BRAF_N CAMKII_N CREB_N ## 1 0.3063817 0.4026984 0.2969273 1.0220603 0.6056726 1.877684 2.308745 0.4415994 0.8593658 0.4162891 0.3696080 0.1789443 ## 2 0.2990511 0.3859868 0.2813189 0.9566759 0.5875587 1.725774 2.043037 0.4452219 0.8346593 0.4003642 0.3561775 0.1736797 ## 3 0.2912761 0.3810025 0.2817103 1.0036350 0.6024488 1.731873 2.017984 0.4676679 0.8143294 0.3998469 0.3680888 0.1739047 ## 4 0.2967287 0.3770870 0.3138320 0.8753903 0.5202932 1.566852 2.132754 0.4776707 0.7277046 0.3856387 0.3629700 0.1794489 ## 5 0.2869612 0.3635021 0.2779643 0.8649120 0.5079898 1.480059 2.013697 0.4834161 0.6877937 0.3675305 0.3553109 0.1748355 ## 6 0.2898239 0.3638930 0.2668369 0.8591209 0.5213066 1.538244 1.968275 0.4959000 0.6724022 0.3694045 0.3571717 0.1797285 ## ELK_N ERK_N GSK3B_N JNK_N MEK_N TRKA_N RSK_N APP_N Bcatenin_N SOD1_N MTOR_N P38_N ## 1 1.866358 3.685247 1.537227 0.2645263 0.3196770 0.8138665 0.1658460 0.4539098 3.037621 0.3695096 0.4585385 0.3353358 ## 2 1.761047 3.485287 1.509249 0.2557270 0.3044187 0.7805042 0.1571935 0.4309403 2.921882 0.3422793 0.4235599 0.3248347 ## 3 1.765544 3.571456 1.501244 0.2596135 0.3117467 0.7851540 0.1608954 0.4231873 2.944136 0.3436962 0.4250048 0.3248517 ## 4 1.286277 2.970137 1.419710 0.2595358 0.2792181 0.7344917 0.1622099 0.4106149 2.500204 0.3445093 0.4292113 0.3301208 ## 5 1.324695 2.896334 1.359876 0.2507050 0.2736672 0.7026991 0.1548274 0.3985498 2.456560 0.3291258 0.4087552 0.3134148 ## 6 1.227450 2.956983 1.447910 0.2508402 0.2840436 0.7043958 0.1568759 0.3910472 2.467133 0.3275978 0.4044899 0.2962764 ## pMTOR_N DSCR1_N AMPKA_N NR2B_N pNUMB_N RAPTOR_N TIAM1_N pP70S6_N NUMB_N P70S6_N pGSK3B_N ## 1 0.8251920 0.5769155 0.4480993 0.5862714 0.3947213 0.3395706 0.4828639 0.2941698 0.1821505 0.8427252 0.1926084 ## 2 0.7617176 0.5450973 0.4208761 0.5450973 0.3682546 0.3219592 0.4545193 0.2764306 0.1820863 0.8476146 0.1948153 ## 3 0.7570308 0.5436197 0.4046298 0.5529941 0.3638799 0.3130859 0.4471972 0.2566482 0.1843877 0.8561658 0.2007373 ## 4 0.7469798 0.5467626 0.3868603 0.5478485 0.3667707 0.3284919 0.4426497 0.3985340 0.1617677 0.7602335 0.1841694 ## 5 0.6919565 0.5368605 0.3608164 0.5128240 0.3515510 0.3122063 0.4190949 0.3934470 0.1602002 0.7681129 0.1857183 ## 6 0.6744186 0.5397231 0.3542143 0.5143164 0.3472241 0.3031321 0.4128243 0.3825783 0.1623303 0.7796946 0.1867930 ## pPKCG_N CDK5_N S6_N ADARB1_N AcetylH3K9_N RRP1_N BAX_N ARC_N ERBB4_N nNOS_N Tau_N ## 1 1.443091 0.2947000 0.3546045 1.339070 0.1701188 0.1591024 0.1888517 0.1063052 0.1449893 0.1766677 0.1251904 ## 2 1.439460 0.2940598 0.3545483 1.306323 0.1714271 0.1581289 0.1845700 0.1065922 0.1504709 0.1783090 0.1342751 ## 3 1.524364 0.3018807 0.3860868 1.279600 0.1854563 0.1486963 0.1905322 0.1083031 0.1453302 0.1762129 0.1325604 ## 4 1.612382 0.2963818 0.2906795 1.198765 0.1597991 0.1661123 0.1853235 0.1031838 0.1406558 0.1638042 0.1232096 ## 5 1.645807 0.2968294 0.3093450 1.206995 0.1646503 0.1606870 0.1882214 0.1047838 0.1419830 0.1677096 0.1368377 ## 6 1.634615 0.2880373 0.3323671 1.123445 0.1756929 0.1505939 0.1838235 0.1064762 0.1395645 0.1748445 0.1305147 ## GFAP_N GluR3_N GluR4_N IL1B_N P3525_N pCASP9_N PSD95_N SNCA_N Ubiquitin_N pGSK3B_Tyr216_N SHH_N ## 1 0.1152909 0.2280435 0.1427556 0.4309575 0.2475378 1.603310 2.014875 0.1082343 1.0449792 0.8315565 0.1888517 ## 2 0.1182345 0.2380731 0.1420366 0.4571562 0.2576322 1.671738 2.004605 0.1097485 1.0098831 0.8492704 0.2004036 ## 3 0.1177602 0.2448173 0.1424450 0.5104723 0.2553430 1.663550 2.016831 0.1081962 0.9968476 0.8467087 0.1936845 ## 4 0.1174394 0.2349467 0.1450682 0.4309959 0.2511031 1.484624 1.957233 0.1198832 0.9902247 0.8332768 0.1921119 ## 5 0.1160478 0.2555277 0.1408705 0.4812265 0.2517730 1.534835 2.009109 0.1195244 0.9977750 0.8786678 0.2056042 ## 6 0.1152432 0.2368495 0.1364536 0.4785775 0.2444853 1.507777 2.003535 0.1206872 0.9201782 0.8436793 0.1904695 ## BAD_N BCL2_N pS6_N pCFOS_N SYP_N H3AcK18_N EGR1_N H3MeK4_N CaNA_N Genotype Treatment Behavior ## 1 0.1226520 NA 0.1063052 0.1083359 0.4270992 0.1147832 0.1317900 0.1281856 1.675652 Control Memantine C/S ## 2 0.1166822 NA 0.1065922 0.1043154 0.4415813 0.1119735 0.1351030 0.1311187 1.743610 Control Memantine C/S ## 3 0.1185082 NA 0.1083031 0.1062193 0.4357769 0.1118829 0.1333618 0.1274311 1.926427 Control Memantine C/S ## 4 0.1327812 NA 0.1031838 0.1112620 0.3916910 0.1304053 0.1474442 0.1469011 1.700563 Control Memantine C/S ## 5 0.1299541 NA 0.1047838 0.1106939 0.4341538 0.1184814 0.1403143 0.1483799 1.839730 Control Memantine C/S ## 6 0.1315752 NA 0.1064762 0.1094457 0.4398331 0.1166572 0.1407664 0.1421804 1.816389 Control Memantine C/S ## class ## 1 c-CS-m ## 2 c-CS-m ## 3 c-CS-m ## 4 c-CS-m ## 5 c-CS-m ## 6 c-CS-m nomes&lt;-colnames(dados) tabela1&lt;-data.frame(Proteina=as.character(NA),Media=NA,Mediana=NA, Desvio=NA, Minimo=NA,Maximo=NA,Normalidade=NA) i&lt;-2 j&lt;-1 for (i in i:78) { nome_snp&lt;-nomes[i] m&lt;-mean(dados[,i],na.rm=T) md&lt;-median(dados[,i],na.rm=T) std&lt;-sd(dados[,i],na.rm=T) mi&lt;-min(dados[,i],na.rm=T) ma&lt;-max(dados[,i],na.rm=T) x&lt;-lillie.test(dados[,i]) p&lt;-x$p.value tabela1[j,]&lt;-data.frame(Proteina=as.character(nome_snp),Media=m,Mediana=md, Desvio=std, Minimo=mi,Maximo=ma, Normalidade=p) j&lt;-j+1 } library(knitr) library(kableExtra) library(ggplot2) Agora podemos formatar a tabela e exibir o resulado: kable(tabela1, caption=&quot;Tabela 1. Arquivo Cortex: análise descritiva&quot;, escape = F)%&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;, &quot;condensed&quot;, &quot;responsive&quot;), full_width = F) (#tab:12- markdown 2)Tabela 1. Arquivo Cortex: análise descritiva Proteina Media Mediana Desvio Minimo Maximo Normalidade DYRK1A_N 0.4258102 0.3663776 0.2493620 0.1453265 2.5163674 0.0000000 ITSN1_N 0.6171020 0.5657818 0.2516400 0.2453585 2.6026621 0.0000000 BDNF_N 0.3190884 0.3165642 0.0493831 0.1151814 0.4971599 0.0000669 NR1_N 2.2972691 2.2965459 0.3472929 1.3308307 3.7576413 0.7412549 NR2A_N 3.8439339 3.7608554 0.9331001 1.7375399 8.4825534 0.0000087 pAKT_N 0.2331681 0.2311767 0.0416345 0.0632360 0.5390501 0.0001755 pBRAF_N 0.1818464 0.1823022 0.0270421 0.0640426 0.3170656 0.0009099 pCAMKII_N 3.5371091 3.3265198 1.2951695 1.3439982 7.4640702 0.0000000 pCREB_N 0.2125739 0.2105943 0.0325870 0.1128118 0.3062472 0.0071059 pELK_N 1.4286819 1.3558456 0.4669037 0.4290323 6.1133475 0.0000000 pERK_N 0.5459041 0.4436439 0.3453091 0.1491552 3.5666854 0.0000000 pJNK_N 0.3135054 0.3213296 0.0519781 0.0521104 0.4934259 0.0000000 PKCA_N 0.3179395 0.3129771 0.0522363 0.1914307 0.4739920 0.0000007 pMEK_N 0.2750332 0.2773925 0.0461636 0.0568182 0.4580006 0.0168937 pNR1_N 0.8258128 0.8210764 0.1179692 0.5001597 1.4081688 0.0960042 pNR2A_N 0.7269328 0.7195913 0.1880132 0.2812848 1.4127502 0.0470035 pNR2B_N 1.5619653 1.5636965 0.2707372 0.3016086 2.7239654 0.5573777 pPKCAB_N 1.5253377 1.3657443 0.4817800 0.5678405 3.0613871 0.0000000 pRSK_N 0.4428477 0.4405978 0.0666722 0.0959416 0.6509618 0.0000459 AKT_N 0.6822365 0.6824689 0.1274340 0.0644212 1.1821747 0.0106329 BRAF_N 0.3785185 0.3266579 0.2163879 0.1438936 2.1334157 0.0000000 CAMKII_N 0.3633566 0.3602602 0.0523518 0.2129595 0.5862445 0.0000002 CREB_N 0.1804916 0.1795798 0.0263702 0.1136364 0.3195582 0.0011003 ELK_N 1.1733998 1.0961858 0.3357856 0.4976950 2.8029483 0.0000000 ERK_N 2.4744915 2.4014622 0.6533970 1.1317957 5.1984041 0.0000000 GSK3B_N 1.1726026 1.1598224 0.2447518 0.1511243 2.4757512 0.0000051 JNK_N 0.2416441 0.2449473 0.0339009 0.0462978 0.3871907 0.0000000 MEK_N 0.2727890 0.2733610 0.0410755 0.1472015 0.4154079 0.0035729 TRKA_N 0.6931796 0.7049644 0.1208253 0.1987434 1.0016229 0.0000000 RSK_N 0.1684168 0.1666920 0.0281377 0.1073944 0.3051360 0.0000267 APP_N 0.4048083 0.4020387 0.0611728 0.2355954 0.6326627 0.0029963 Bcatenin_N 2.1465500 2.1147694 0.4357422 1.1348861 3.6805518 0.0131664 SOD1_N 0.5426346 0.4441345 0.2805681 0.2171202 1.8728985 0.0000000 MTOR_N 0.4524587 0.4524914 0.0654883 0.2011434 0.6767480 0.0000448 P38_N 0.4153108 0.4077935 0.0892897 0.2278804 0.9332563 0.0000027 pMTOR_N 0.7590468 0.7607562 0.1224459 0.1665787 1.1248834 0.0012843 DSCR1_N 0.5851857 0.5767120 0.1006012 0.1553210 0.9164295 0.0000000 AMPKA_N 0.3683699 0.3585030 0.0625834 0.2264087 0.7008385 0.0000000 NR2B_N 0.5653166 0.5634724 0.0882014 0.1847845 0.9720198 0.0001657 pNUMB_N 0.3570947 0.3473567 0.0630253 0.1855976 0.6310522 0.0000000 RAPTOR_N 0.3158128 0.3048973 0.0541627 0.1948245 0.5266814 0.0000000 TIAM1_N 0.4186054 0.4071995 0.0672879 0.2377771 0.7221216 0.0000000 pP70S6_N 0.3944753 0.3777001 0.1561702 0.1311198 1.1291715 0.0000000 NUMB_N 0.1810801 0.1782350 0.0292964 0.1179985 0.3165753 0.0000000 P70S6_N 0.9431161 0.9312826 0.1728377 0.3441198 1.6799532 0.0001440 pGSK3B_N 0.1612110 0.1602122 0.0193079 0.0999759 0.2532101 0.0000000 pPKCG_N 1.7065987 1.6645600 0.5784423 0.5987666 3.3819763 0.0021165 CDK5_N 0.2924341 0.2938195 0.0373799 0.1811570 0.8174018 0.0000000 S6_N 0.4292256 0.4009994 0.1374403 0.1302063 0.8226108 0.0000000 ADARB1_N 1.1974200 1.1282548 0.3617434 0.5291078 2.5398896 0.0000000 AcetylH3K9_N 0.2164822 0.1504173 0.1853087 0.0525284 1.4593869 0.0000000 RRP1_N 0.1666312 0.1620995 0.0318956 -0.0620079 0.6123770 0.0000000 BAX_N 0.1793067 0.1807448 0.0188264 0.0723255 0.2411411 0.0000033 ARC_N 0.1215208 0.1216265 0.0142765 0.0672543 0.1587478 0.0164045 ERBB4_N 0.1564775 0.1563714 0.0150708 0.1002173 0.2086975 0.0066606 nNOS_N 0.1813001 0.1826720 0.0249190 0.0997344 0.2607386 0.0522203 Tau_N 0.2104892 0.1886295 0.0690099 0.0962328 0.6027681 0.0000000 GFAP_N 0.1208891 0.1204592 0.0132333 0.0861142 0.2136206 0.0000001 GluR3_N 0.2218510 0.2169020 0.0348858 0.1113821 0.3310159 0.0000000 GluR4_N 0.1265601 0.1235490 0.0268850 0.0725797 0.5370041 0.0000000 IL1B_N 0.5273487 0.5266815 0.0820574 0.2840013 0.8897351 0.1160793 P3525_N 0.2912763 0.2906460 0.0300151 0.2074378 0.4437350 0.0298268 pCASP9_N 1.5483477 1.5226932 0.2481315 0.8531756 2.5862159 0.0000035 PSD95_N 2.2352360 2.2421973 0.2543948 1.2060978 2.8778734 0.0035208 SNCA_N 0.1598210 0.1575492 0.0241501 0.1012332 0.2576159 0.0000003 Ubiquitin_N 1.2392704 1.2365858 0.1735803 0.7506641 1.8972023 0.1640128 pGSK3B_Tyr216_N 0.8487666 0.8498583 0.0943114 0.5773968 1.2045981 0.0001821 SHH_N 0.2266765 0.2239997 0.0289890 0.1558693 0.3582888 0.0000000 BAD_N 0.1579142 0.1523133 0.0295365 0.0883046 0.2820163 0.0000000 BCL2_N 0.1347617 0.1294683 0.0274170 0.0806568 0.2615057 0.0000000 pS6_N 0.1215208 0.1216265 0.0142765 0.0672543 0.1587478 0.0164045 pCFOS_N 0.1310530 0.1265230 0.0238627 0.0854192 0.2565289 0.0000000 SYP_N 0.4460730 0.4484586 0.0664322 0.2586258 0.7595884 0.1174341 H3AcK18_N 0.1696092 0.1582403 0.0594023 0.0796909 0.4797633 0.0000000 EGR1_N 0.1831345 0.1749352 0.0404056 0.1055372 0.3606921 0.0000000 H3MeK4_N 0.2054396 0.1939935 0.0555139 0.1017870 0.4139027 0.0000000 CaNA_N 1.3377837 1.3174408 0.3171262 0.5864788 2.1297911 0.0000000 12.1 Incluindo gráficos Você pode incluir um gráfico, como no exemplo abaixo: Veja que com echo = FALSE adicionado ao chunk previne que o código seja incluído no documento gerado. 12.2 Chunk: opções As opções de chunk são escritas nos cabeçalhos. Por exemplo: {r my-chunk, fig.height=4, dev=‘jpeg’, my-chunk, echo=FALSE} Uma opção de chunk especial é o rótulo (my-chunk, no exemplo acima). O rótulo para cada chunk é considerado exclusivo dentro do documento. Isso é especialmente importante para nomes de arquivos de cache e plotagem, porque esses nomes de arquivos são baseados em rótulos de chunk. Execução do código eval: (TRUE; lógico ou numérico) Se deve executar o código do chunk. Também pode ser um vetor numérico para escolher quais expressões R executar, por exemplo, eval = c(1, 3, 4) avaliará a primeira, terceira e quarta expressões e eval = -(4:5) avaliará todas as expressões, exceto a quarta e a quinta. Saída de texto echo: (TRUE; lógico ou numérico) Se o código-fonte deve ser exibido no documento de saída. Além de TRUE/FALSE, que mostra/oculta o código-fonte, também podemos usar um vetor numérico para escolher qual(is) expressão(ões) R ecoará em um pedaço, por exemplo, echo = 2:3 significa ecoar apenas a 2ª e a 3ª expressões , e echo = -4 significa excluir a 4ª expressão. Outras opções: https://yihui.org/knitr/options/ 12.3 Formatação Para formatar um um texto em itálico, coloque o texto entre asteriscos. Para negrito, coloque entre 2 asteriscos. Para subescrito coloque em sinais de til (H2O) e para sobrescrito, coloque entre acentos circunflexos (p2). Também podemos inserir códigos dentro das linhas. Nesse caso, o código deve ser inserido entre sinais de crase. x&lt;-c(34,45,12,33,56,74,42,23,45,55) media&lt;-mean(x) Então em vez de digitar um valor no texto, podemos fazer assim: O tamnho da amostra é N = length(x), a média é mean(x) e o desvio padrão é sd(x). Para saber mais: (Xie, Allaire, and Grolemund 2023) References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
